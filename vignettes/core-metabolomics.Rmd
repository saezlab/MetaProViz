---
title: "core Metabolomics"
author:
  - name: Christina Schmidt
    affiliation:
    - Heidelberg University
  - name: Dimitrios Prymidis
    affiliation:
    - Cologne University
output:
  html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 5
    code_folding: show
vignette: >
  %\VignetteIndexEntry{Standard Metabolomics}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: bibliography.bib
editor_options:
  chunk_output_type: console
---

<style>
.vscroll-plot {
    width: 850px;
    height: 500px;
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# <img src="Hexagon_MetaProViz.png" align="right" width="200" />
\
A Consumption-Release (core) metabolomics experiment usually refers to a cell culture experiment where metabolomics is performed on the cell culture media.\
\
<span style="text-decoration:underline">In this tutorial we showcase how to use **MetaProViz**</span>:\

* to process raw peak data and identify outliers.\
* to perform differential metabolite analysis (dma) to generate Log2Distance and statistics and perform pathway analysis using Over Representation Analysis (ORA) on the results.\
* to do metabolite clustering analysis (MCA) to find clusters of metabolites with similar behaviors and perform pathway analysis using ORA on each cluster.\
* to use specific visualizations to aid biological interpretation of the results.\
\
\
First if you have not done yet, install the required dependencies and load the libraries:
```{r, message=FALSE, warning=FALSE}
# 1. Install Rtools if you haven’t done this yet, using the appropriate version (e.g.windows or macOS).
# 2. Install the latest development version from GitHub using devtools
# devtools::install_github("https://github.com/saezlab/MetaProViz")

library(MetaProViz)

# dependencies that need to be loaded:
library(magrittr)
library(dplyr)
library(tibble)
library(rlang)
library(ggfortify)
library(stringr)
library(tibble)

# Please install the Biocmanager Dependencies:
# BiocManager::install("clusterProfiler")
# BiocManager::install("EnhancedVolcano")
```
\
\
<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

# 1. Loading the example data

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

Here we choose an example datasets, which is publicly available on [metabolomics workbench project PR001418](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Project&ProjectID=PR001418) including metabolic profiles of human renal epithelial cells HK2 and cell renal cell carcinoma (ccRCC) cell lines cultured in Plasmax cell culture media. Here we use the integrated raw peak data as example data using the trivial metabolite name in combination with the KEGG ID as the metabolite identifiers.\
\
<span style="text-decoration:underline">As part of the **MetaProViz** package you can load the example data into your global environment using the function `toy_data()`</span>:\
\
`1.` core experiment **(core)** \
The raw data are available via [metabolomics workbench study ST002226](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Study&StudyID=ST002226&StudyType=MS&ResultType=1) were exometabolomics of HK2 and ccRCC cell lines 786-O, 786-M1A, 786-M2A, OS-RC-2, OS-LM1 and RFX-631 were performed.\
```{r}
Media <- medium_raw%>%
  column_to_rownames("Code")

```
```{r, echo=FALSE}
# Check how our data looks like:
Media[6:12, 1:8]%>%
  kableExtra::kbl(caption = "Preview of the DF `core` including columns with sample information and metabolite ids with their measured values.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12) #%>%
  #kableExtra::scroll_box(width = "100%", height = "200px")
```
\
`2.` Additional information mapping the trivial metabolite names to KEGG IDs and selected pathways **(MappingInfo)** \
```{r}
MappingInfo <- cellular_meta%>%
  column_to_rownames("Metabolite")
```
```{r, echo=FALSE}
# Check how our data looks like:
MappingInfo[1:5,]%>%
  kableExtra::kbl(caption = "Preview of the DF `Pathways` including the trivial metabolite identifiers used in the experiment as well as KEGG IDs and pathway information.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12) #%>%
  #kableExtra::scroll_box(width = "100%", height = "200px")
```
\
`3.` KEGG pathways that are loaded via KEGG API using the package `KEGGREST` and can be used to perform pathway analysis. **(KEGG_Pathways)**\
```{r}
# This will use KEGGREST to query the KEGG API to load the pathways:
KEGG_Pathways <- MetaProViz::metsigdb_kegg()
```
```{r, echo=FALSE}
# Check how our data looks like:
KEGG_Pathways[1:5,]%>%
  kableExtra::kbl(caption = "Preview of the DF `KEGG_Pathways`.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12) #%>%
  #kableExtra::scroll_box(width = "100%", height = "200px")
```
\
\
<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 550%"></div>
</div>

# 2. Run MetaProViz Analysis

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 550%"></div>
</div>

Currently, **MetaProViz** contains four different modules, which include different methods and can be used independently from each other or in combination (see introduction for more details). Here we will go trough each of those modules and apply them to the example data.

## Pre-processing
**MetaProViz** includes a pre-processing module with the function `Preprocessing()` that has multiple parameters to perform customize data processing.\
`Feature_Filtering` applies the 80%-filtering rule on the metabolite features either on the whole dataset (="Standard") [@Bijlsma2006] or per condition (="Modified") [@Wei2018].  This means that metabolites are removed were more than 20% of the samples (all or per condition) have no detection. In case of the core experiment, the blank samples are ignored during feature filtering, since often metabolites are released from a cell and not naturally present in the culture media leading to no detection in the blank. With the parameter `Feature_Filt_Value` we enable the adaptation of the stringency of the filtering based on the experimental context. For instance, patient tumour samples can contain many unknown subgroups due to gender, age, stage etc., which leads to a metabolite being detected in only 50% (or even less) of the tumour samples, hence in this context it could be considered to change the `Feature_Filt_Value` from the default (=0.8). If `Feature_Filtering = "None"`, no feature filtering is performed. In the context of `Feature_Filtering` it is also noteworthy that the function `Pool_Estimation()` can be used to estimate the quality of the metabolite detection and will return a list of metabolites that are variable across the different pool measurements (pool = mixture of all experimental samples measured several times during the LC-MS run) . Variable metabolite in the pool sample should be removed from the data.\
The parameter `tic_Normalization` refers to total Ion Count (tic) normalisation, which is often used with LC-MS derived metabolomics data. If `tic_Normalization = TRUE`, each feature (=metabolite) in a sample is divided by the sum of all intensity value (= total number of ions)  for the sample and finally multiplied by a constant ( = the mean of all samples total number of ions). Noteworthy, tic normalisation should not be used with small number of features (= metabolites), since tic assumes that on “average” the ion count of each sample is equal if there were no instrument batch effects [@Wulff2018].\
The parameter `mvi` refers to Missing Value Imputation (mvi) and if `mvi = TRUE` half minimum (HM) missing value imputation is performed per feature (= per metabolite). Here it is important to mention that HM has been shown to perform well for missing vales that are missing not at random (MNAR) [@Wei2018].\
Lastly, the function `Preprocessing()` performs outlier detection and adds a column "Outliers" into the DF, which can be used to remove outliers. The parameter `hotellins_confidence` can be used to choose the confidence interval that should be used for the Hotellins T2 outlier test [@Hotelling1931].\
\
Since our example data contains pool samples, we will do `Pool_Estimation()` before applying the `Preprocessing()` function. This is important, since one should remove the features (=metabolites) that are too variable prior to performing any data transformations such as tic as part of the `Preprocessing()` function.\
It is worth mentioning that the Coefficient of variation (CV) is calculated by dividing the standard deviation (SD) by the mean. Hence CV depends on the SD, which in turn works for normally distributed data.\
```{r, eval=FALSE}
Pool_Estimation_result<- MetaProViz::pool_estimation(data = Media[,-c(1:3)],
                                                    metadata_sample = Media[,1:3],
                                                    metadata_info = c(PoolSamples = "Pool", Conditions="Conditions"),
                                                    cutoff_cv = 30)

Pool_Estimation_result_DF_CV <-Pool_Estimation_result[["DF"]][["CV"]]
```

<div class="vscroll-plot">
```{r, echo=FALSE, warning=FALSE,  fig.width=6, fig.height=4.5, fig.align="left"}
Pool_Estimation_result<- MetaProViz::pool_estimation(data = Media[,-c(1:3)],
                                                    metadata_sample = Media[,1:3],
                                                    metadata_info = c(PoolSamples = "Pool", Conditions="Conditions"),
                                                    cutoff_cv = 30)

Pool_Estimation_result_DF_CV <-Pool_Estimation_result[["DF"]][["CV"]]
```
</div>
\
\
\
```{r, echo=FALSE}
# Check how our data looks like:
Pool_Estimation_result_DF_CV[1:5,]%>%
  kableExtra::kbl(caption = "Preview of the Pool_Estimation result.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
The results from the `Pool_Estimation()` is a table that has the CVs. If there is a high variability, one should consider to remove those features from the data. For the example data nothing needs to be removed. If you have used internal standard in your experiment you should specifically check their CV as this would indicate technical issues (here valine-d8 and hippuric acid-d5).\
\
Now we will apply the `Preprocessing()` function to the example data and have a look at the output produced. You will notice that all the chosen parameters and results are documented in messages. All the results data tables, the Quality Control (QC) plots and outlier detection plots are returned and can be easily viewed. Importantly, here we are able to specify that we have a core experiment setting the parameter `core=TRUE`, in which case a few additional data processing steps are applied:\
`1.` **Blank sample**: This refers to media samples where no cells have been cultured in, which will be used as blank. In detail, the mean of the blank sample of a feature (= metabolite) will be substracted from the values measured in each sample for the same feature. In the column "Condition" of the Experimental_design DF, you will need to label your blank samples with "blank".\
`2.` **Growth factor** or **growth rate**: This refers to the different conditions and is either based on cell count or protein quantification at the start of the experiment (t0) and at the end of the experiment (t1) resulting in the growth factor (t0/t1). Otherwise, one can experimentally estimate the growth rate of each condition. Ultimately, this measure is used to normalize the data, since the amount of growth will impact the consumption and release of metabolites from the media and hence we need to account for this. If you do not have this information, this will be set to 1, yet be aware that this may affect the results.\
\
You can pass these additional information via the parameter `Input_metadata_info`, by passing the column name for the `core_norm_factor` in the `Input_SettingsFile` and the condition name for the `core_media` in the `Input_data` file.\
```{r, eval=FALSE}
# Prepare the input:
Media_input <- Media%>%
  subset(!Conditions=="Pool", select = -c(1:3))#remove pool samples and remove the information columns

Media_Metadata <- Media%>%
  subset(!Conditions=="Pool", select = c(1:3))#remove pool samples and keep the information columns only

PreProcessing_res <-  MetaProViz::processing(data=Media_input,
                                                metadata_sample =Media_Metadata,
                                                metadata_info = c(Conditions = "Conditions",
                                                                 Biological_Replicates = "Biological_Replicates",
                                                                 core_norm_factor = "GrowthFactor",
                                                                 core_media = "blank"),
                                                featurefilt = "Modified",
                                                cutoff_featurefilt = 0.8,
                                                tic = TRUE,# As we have raw data we will perform total ion count norm
                                                mvi=TRUE, #We assume the values are not missing at random and perform half minimum mvi
                                                mvi_percentage=50,
                                                hotellins_confidence = 0.99,# We perform outlier testing using 0.99 confidence interval
                                                core = TRUE)

# Now we can have a look at the results table:
Media_Preprocessed <-  PreProcessing_res[["DF"]][["Preprocessing_output"]]
```

<div class="vscroll-plot">
```{r, echo=FALSE,   fig.width=6, fig.height=4.5, fig.align="left"}
# Prepare the input:
Media_input <- Media%>%
  subset(!Conditions=="Pool", select = -c(1:3))#remove pool samples and remove the information columns

Media_Metadata <- Media%>%
  subset(!Conditions=="Pool", select = c(1:3))#remove pool samples and keep the information columns only

PreProcessing_res <-  MetaProViz::processing(data=Media_input,
                                                metadata_sample =Media_Metadata,
                                                metadata_info = c(Conditions = "Conditions",
                                                                       Biological_Replicates = "Biological_Replicates",
                                                                       core_norm_factor = "GrowthFactor",
                                                                       core_media = "blank"),
                                                featurefilt = "Modified",
                                                cutoff_featurefilt = 0.8,
                                                tic = TRUE,# As we have raw data we will perform total ion count norm
                                                mvi=TRUE, #We assume the values are not missing at random and perform half minimum mvi
                                                mvi_percentage=50,
                                                hotellins_confidence = 0.99,# We perform outlier testing using 0.99 confidence interval
                                                core = TRUE)

# Now we can have a look at the results table:
Media_Preprocessed <-  PreProcessing_res[["DF"]][["Preprocessing_output"]]
```
</div>
\
\
\
```{r, echo=FALSE}
# Check how our data looks like:
Media_Preprocessed[1:5,1:9]%>%
  kableExtra::kbl(caption = "Preview of the pre-processing results, which has an additional column `Outlier` including the results of Hotellins T2.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
In the output table you can now see the column "Outliers" and for the Condition HK2 CCM, we can see that based on Hotellin's T2 test, samples were detected as outliers in the first and second round of filtering.\
As part of the `Preprocessing()` function several plots are generated  and saved. Additionally, the ggplots are returned into the list to enable further modifiaction using the ggplot syntax. These plots include plots showing the outliers for each filtering round and other QC plots.\
\
As part of the **MetaProViz** visualization module one can easily further customize the PCA plot and adapt color and shape for the information of interest. You can see more below for the `viz_pca()` function.\
Before we proceed, we will remove the outlier:\
```{r}
Media_Preprocessed <-Media_Preprocessed%>%
  subset(!Outliers=="Outlier_filtering_round_1")
```
\
In metabolomics, sometimes samples are injected (=measured) several times, which can be termed as analytical replicates. The **MetaProViz** pre-processing module includes the function `replicate_sum()`, which will summarize those and save the results.

## dma
Differential Metabolite Analysis (`dma`) between two conditions (e.g. Tumour versus Healthy) usually calculates the Log2FC, p-value, adjusted p-value and t-value. Yet, in a core experiment the normalized metabolite values can be either a negative value, if the metabolite has been consumed from the media, or a positive value, if the metabolite has been released from the cell into the culture media. Since we can not calculate a Log2FC using negative values, we calculate the absolute difference between the mean of Condition 1 versus the mean of Condition 2. The absolute difference is log2 transformed in order to make the values comparable between the different metabolites, resulting in the Log2Dist. The result doesn't consider whether one product is larger than the other; it only looks at the magnitude of their difference. to reflect the direction of change between the two conditions we multiply with -1 if C1 < C2. By setting the paramteter `core` = TRUE, instead of calclulating the Log2FC, the Log2 Distance is calculated.\
With the different parameters `STAT_pval` and `STAT_padj` one can choose the statistical tests such as t.test, wilcoxon test, limma, annova, kruskal walles, etc. (see function reference for more information).\
As input one can use the  pre-processed data we have generated using the `Preprocessing` module, but here one can of course use any DF including metabolite values, even though we recommend to normalize the data and remove outliers prior to dma. Moreover, we require the `Input_metadata_sample` including the sample metadata with information which condition a sample corresponds to. Additionally, we enable the user to provide a `Plot_metadata_feature` containing the metadata for the features (metabolites), such as KEGG ID, pathway, retention time, etc.\
\
By defining the numerator and denominator as part of the `Input_metadata_info` parameter, it is defined which comparisons are performed:\
1. **one_vs_one** (single comparison): numerator="Condition1", denominator ="Condition2"\
2. **all_vs_one** (multiple comparison): numerator=NULL, denominator ="Condition"\
3. **all_vs_all** (multiple comparison): numerator=NULL, denominator =NULL (=default)\
\
As input we will use the  pre-processed data we have generated using the `Preprocessing` module, but here one can of course use any DF including metabolite values and information about the conditions that should be compared (even though we recommend to normalize the data and remove outliers prior to dma).\
\
In the example data we have seven different cell lines, healthy (HK2) and cancer (ccRCC: 786-M1A, 786-M2A, 786-O, OSRC2, OSLM1B and RFX631) and hence we can perform multiple different comparisons.  The results can be automatically saved and all the results are returned in a list with the different data frames. If parameter Plot=TRUE, an overview Volcano plot is generated and saved.\
```{r, eval=FALSE}
# Perform multiple comparison All_vs_One using annova:
DMA_Annova <-  MetaProViz::dma(data=Media_Preprocessed[,-c(1:6)],
                               metadata_sample=Media_Preprocessed[,c(1:4)],
                               metadata_info = c(Conditions="Conditions", Numerator=NULL, Denominator = "HK2"),
                               pval ="aov",
                               padj="fdr",
                               metadata_feature = MappingInfo,
                               core=TRUE)

# Inspect the dma results tables:
DMA_786M1A_vs_HK2 <- DMA_Annova[["dma"]][["786-M1A_vs_HK2"]]
DMA_786O_vs_HK2 <- DMA_Annova[["dma"]][["786-O_vs_HK2"]]

shapiro <- DMA_Annova[["ShapiroTest"]][["DF"]][["Shapiro_result"]]
```

<div class="vscroll-plot">
```{r, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5, fig.align="left"}
# Perform multiple comparison All_vs_One using annova:
DMA_Annova <-  MetaProViz::dma(data=Media_Preprocessed[,-c(1:6)],
                               metadata_sample=Media_Preprocessed[,c(1:4)],
                               metadata_info = c(Conditions="Conditions", Numerator=NULL, Denominator = "HK2"),
                               pval ="aov",
                               padj="fdr",
                               metadata_feature = MappingInfo,
                               core=TRUE)

# Inspect the dma results tables:
DMA_786M1A_vs_HK2 <- DMA_Annova[["dma"]][["786-M1A_vs_HK2"]]
DMA_786O_vs_HK2 <- DMA_Annova[["dma"]][["786-O_vs_HK2"]]
shapiro <- DMA_Annova[["ShapiroTest"]][["DF"]][["Shapiro_result"]]
```
</div>
\
\
\
```{r, echo=FALSE}
# Check how our data looks like:
shapiro[,c(1:5)]%>%
  kableExtra::kbl(caption = "1. Preview of the Shaprio results for the different conditions.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)

DMA_786M1A_vs_HK2[c(7,9,11:12,14),]%>%
  kableExtra::kbl(caption = "2. Preview of the dma results for the comparison of 786-M1A versus HK2 cells.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Using the dma results, we can now use the **MetaProViz** visualization module and generate further customized Volcano plots `viz_volcano()`. You can see some examples below.\
\
Additionally to the individual comparison that there is also a summary table created including the individual information about metabolite consumption or release based on the mean measured value:\
```{r}
core_MetaInfo <- DMA_Annova[["Feature_Metadata"]]
```
```{r, echo=FALSE}
# Check how our data looks like:
core_MetaInfo[c(2, 13:16),-c(3:5)]%>%
  kableExtra::kbl(caption = "1. Preview of the consumption-release information for each metabolite and cell line.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
We can also visualize this information by assigning -1 to released, +1 to consumed and 0 for NA:
```{r, echo=FALSE}
core_MetaInfo_transformed <- core_MetaInfo[, -c(2:5)] %>%
  column_to_rownames("Metabolite") %>%  # Set "Metabolite" as row names
  mutate_all(~ case_when(
    . == "Released" ~ 1,
    . == "Consumed" ~ -1,
    TRUE ~ 0
  )) %>%
  t() %>%  # Transpose the dataframe
  as.data.frame() %>% # Convert back to dataframe after transposing
  select_if(~ any(. != 0))%>% # Keep only columns with non-zero entries
  t() %>%  # Transpose the dataframe
  as.data.frame()

heatmap <- pheatmap::pheatmap(
  core_MetaInfo_transformed,
  color = c("#00CEFF", "gray", "#FF84FF"),  # Color scale for values
  cluster_rows = TRUE,               # Optionally cluster rows
  cluster_cols = TRUE,               # Optionally cluster columns
  show_rownames = TRUE,              # Show row names (metabolites)
  show_colnames = TRUE,             # Show column names (conditions)
  cellwidth = 9,
  cellheight = 9
)

# Save
Plot_Sized <- MetaProViz:::plot_grob_heatmap(input_plot=heatmap, metadata_info=NULL, metadata_sample=NULL, metadata_feature=NULL,plot_name= "test")
Plot_Sized %<>%
      {ggplot2::ggplot() + annotation_custom(.)} %>%
      add(theme(panel.background = element_rect(fill = "transparent")))

Plot_Sized
# ggplot2::ggsave(filename = "Plot.svg", plot = Plot_Sized , width = 12,  height = 27, unit="cm")

```

### ORA using the dma results
Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method that determines if a set of features (=metabolic pathways) are over-represented in the selection of features (=metabolites) from the data in comparison to all measured features (metabolites) using the Fishers exact test. The selection of metabolites are usually the most altered metabolites in the data, which can be selected by the top and bottom t-values. Given that for core data it is important to consider weather a metabolite was consumed or released, it is sensible to perform ORA on each metabolite cluster.\
Of course, there are many other PEA methods such as the well known GSEA. Here we do not aim to provide an extensive tool for different methods to perform pathway enrichment analysis and only focus on ORA since we can apply this to perform standard pathway enrichment as well as pathway enrichment on clusters of metabolites. If you are interested in using different pathway enrichment methods please check out specialized tools such as [decopupleR](https://saezlab.github.io/decoupleR/) [@Badia-I-Mompel2022].\
\
Here we will use the KEGG pathways [@Kanehisa2000]. Before we can perform ORA on the dma results, we have to ensure that the metabolite names match with the KEGG IDs or KEGG trivial names. In general, the `input_pathway` requirements are column "term", "Metabolite" and "Description", and the `Input_data` requirements are column "t.val" and column "Metabolite".\
```{r}
# Since we have performed multiple comparisons (all_vs_HK2), we will run ORA for each of this comparison
DM_ORA_res<- list()

comparisons <- names(DMA_Annova[["dma"]])
for(comparison in comparisons){
  #Ensure that the Metabolite names match with KEGG IDs or KEGG trivial names.
  dma_res <- DMA_Annova[["dma"]][[comparison]]
  dma_res <- dma_res[complete.cases(dma_res),-1]%>%#we remove metabolites that do not have a KEGG ID/KEGG pathway
    tibble::remove_rownames()%>%
    column_to_rownames("KEGGCompound")#We use the KEGG trivial names to match with the KEGG pathways

  #Perform ORA: Here we use
  DM_ORA_res[[comparison]] <- MetaProViz::cluster_ora(data=dma_res,
                                                     metadata_info=c(ClusterColumn="core_specific", PathwayTerm= "term", PathwayFeature= "Metabolite"),
                                                     remove_background=FALSE,#we do not have any background
                                                     input_pathway=KEGG_Pathways,
                                                     pathway_name="KEGG",
                                                     min_gssize=3,
                                                     max_gssize=1000)
}

# Lets check how the results look like:
MC_ORA_786M1A_vs_HK2_Consumed <- DM_ORA_res[["786-M1A_vs_HK2"]][["DF"]][["Consumed"]]
```
```{r, echo=FALSE}
# Check how our data looks like:
MC_ORA_786M1A_vs_HK2_Consumed[c(1:5),-1]%>%
  kableExtra::kbl(caption = "Preview of the ORA results for the comparison of 786-M1A versus HK2 cells focusing on pathways enriched in `consumed` metabolites.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```

## MCA
Metabolite Clustering Analysis (`MCA`) is a module, which includes different functions to enable clustering of metabolites into groups based on logical regulatory rules. This can be particularly useful if one has multiple conditions and aims to find patterns in the data.

### mca_core
This metabolite clustering method is based on logical regulatory rules to sort metabolites into metabolite clusters. Here you additionally need intracellular samples corresponding to the core samples.\
Here we will define if a feature (= metabolite) is assigned into:\
1. ***"UP"***, which means a metabolite is significantly up-regulated in the underlying comparison.\
2. ***"DOWN"***,  which means a metabolite is significantly down-regulated in the underlying comparison.\
3. ***"No Change"***, which means a metabolite does not change significantly in the underlying comparison and/or is not defined as up-regulated/down-regulated based on the Log2FC threshold chosen.\
\
Therebye “No Change” is further subdivided into four states:\
1. ***“Not Detected”***, which means a metabolite is not detected in the underlying comparison.\
2. ***“Not Significant”***, which means a metabolite is not significant in the underlying comparison.\
3. ***“Significant positive”***, which means a metabolite is significant in the underlying comparison and the differential metabolite abundance is positive, yet does not meet the threshold set for "UP" (e.g. Log2FC >1 = "UP" and we have a significant Log2FC=0.8).\
4. ***“Significant negative”***, which means a metabolite is significant in the underlying comparison and the differential metabolite abundance is negative, yet does not meet the threshold set for "DOWN".\
\
Lastly, we also take into account the core direction, meaning if a metabolite was:\
1. ***“Released”***, which means is released into the media in both conditions of the underlying comparison.\
2. ***“Consumed”***, which means is consumed from the media in both conditions of the underlying comparison.\
3. ***“Released/Consumed”***, which means is consumed/released in one condition, whilst the opposite occurs in the second condition of the underlying comparison.\
4. ***“Not Detected”***, which means a metabolite is not detected in the underlying comparison.
\
This definition is done individually for each comparison and will impact in which metabolite cluster a metabolite is sorted into. \
Since we have two comparisons (Intracellular and core), we can choose between different Background settings, which defines which features will be considered for the clusters (e.g. you could include only features (= metabolites) that are detected in both comparisons, removing the rest of the features).The background methods `method_background` are the following from ***1.1. - 1.4.*** from most restrictive to least restrictive:\
***1.1. Intra&core***: Most stringend background setting and will lead to a small number of metabolites.\
***1.2. core***: Focus is on the metabolite abundance of the core.\
***1.3. Intra***: Focus is on the metabolite abundance of intracellular.\
***1.4. Intra|core***: Least stringent background method, since a metabolite will be included in the input if it has been detected on one of the two conditions.\
\
Lastly, we will get clusters of metabolites that are defined by the metabolite change in the two conditions. For example, if Alanine is "UP" based on the thresholds in both comparisons it will be sorted into the cluster "core_UP". As there are three 6-state6-state4 transitions between the comparisons, the flows are summarised into smaller amount of metabolite clusters using different Regulation Groupings (RG):
1. RG1_All\
2. RG2_Significant taking into account genes that are significant (UP, DOWN, significant positive, significant negative)\
3. RG3_SignificantChange only takes into account genes that have significant changes (UP, DOWN).\
\
In order to define which group a metabolite is assigned to, we set two different thresholds. For intracellular those are based on the differential metabolite abundance (`Log2FC`) and the `significance` (e.g. p.adj). For the core data this is based on the `Log2 Distance` and the `significance` (e.g. p.adj). For `Log2FC` we recommend a threshold of 0.5 or 1, whilst for the `Log2 Distance` one should check the distance ranges and base the threshold on this.\
\
Regulatory rules:\
\
```{r}
# Example of all possible flows:
MCA_CoRe_Rule <- mca_core_rules
```
```{r, echo=FALSE}
# Check how our data looks like:
MCA_CoRe_Rule[,1:6]%>%
  kableExtra::kbl(caption ="Metabolite Clustering Analysis: core.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
```{r, eval=FALSE, include=FALSE}
# Alluvial plot of the rules:
Plot<- easyalluvial::alluvial_wide(MCA_CoRe_Rule[,c(1:3,5,6)], fill_by = 'last_variable' )+
      ggplot2::ggtitle("Regulatory rules resulting in the regulatory clusters that are based on signifcant change") +
      ggplot2::theme_classic() +
      ggplot2::theme(axis.text.y=ggplot2::element_blank(),  #remove y axis labels
                     axis.ticks.y=ggplot2::element_blank(), #remove y axis ticks
                     axis.title.y=ggplot2::element_blank(),
                     axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust=1))

# ggplot2::ggsave("AlluvialOverview_RG3SignificantChange2.svg", plot=Plot, width=8, height=15)

#######################
# Summarize "Not Detected", "Significant Negative", "Significant Positive", "Not Significant" into "No Change

MCA_core_Compressed <- MCA_CoRe_Rule %>%
  mutate(Intra = case_when(
    Intra %in% c("UP", "DOWN") ~ Intra,  # Keep "UP" and "DOWN" as they are
    Intra %in% c("Not Detected", "Significant Negative", "Significant Positive", "Not Significant") ~ "No Change",
    TRUE ~ NA_character_  # Handle unexpected values
  )) %>%
  mutate(core = case_when(
    core %in% c("UP", "DOWN") ~ core,  # Keep "UP" and "DOWN" as they are
    core %in% c("Not Detected", "Significant Negative", "Significant Positive", "Not Significant") ~ "No Change",
    TRUE ~ NA_character_  # Handle unexpected values
  ))%>%
  distinct(Intra, core, core_Direction, .keep_all = TRUE)%>%  # Keep only unique rows based on these columns
  filter(!core_Direction=="Not Detected")#remove the "Not Detected" as we are only interested in the released/consumed metabolites


Plot1<- easyalluvial::alluvial_wide(MCA_core_Compressed[,c(1:3,5)], fill_by = 'last_variable' )+
      ggplot2::ggtitle("Regulatory rules resulting in the regulatory clusters that are based on signifcant change") +
      ggplot2::theme_classic() +
      ggplot2::theme(axis.text.y=ggplot2::element_blank(),  #remove y axis labels
                     axis.ticks.y=ggplot2::element_blank(), #remove y axis ticks
                     axis.title.y=ggplot2::element_blank(),
                     axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust=1))

# ggplot2::ggsave("AlluvialOverview_RG2_NoChange.svg", plot=Plot1, width=8, height=15)
```
\
Now we can load the corresponding pre-processed intracellular example data for the comparison of 786M-1A versus HK2 (For the detailed pre-processing please see the vignette "Standard Metabolomics").
```{r}
# Load the Pre-processed intracellular data:
Intra_DMA_786M1A_vs_HK2 <- intracell_dma%>%
  as.data.frame()

# Perform metabolite clustering:
MCA_core_res <- MetaProViz::mca_core(data_intra =Intra_DMA_786M1A_vs_HK2,
                                     data_core = DMA_786M1A_vs_HK2,
                                     metadata_info_intra=c(ValueCol="Log2FC",StatCol="p.adj", cutoff_stat= 0.05, ValueCutoff=0.8),
                                     metadata_info_core=c(DirectionCol="core", ValueCol="Log2(Distance)",StatCol="p.adj", cutoff_stat= 0.05, ValueCutoff=28),
                                     feature= "Metabolite",
                                     method_background="Intra&core",
                                     path=NULL)

# Lets check how the results look like:
MCA_res <- MCA_core_res[["MCA_core_Results"]]
Clustersummary <- MCA_core_res[["MCA_core_summary"]]
```
```{r, echo=FALSE}
# Check how our data looks like:
MCA_res[c(17:18, 29, 46),c(1, 5:7,10:15)]%>%
  kableExtra::kbl(caption = "MetaProViz::mca_core for the comparison of 786-M1A versus HK2 cells in intracellular and core samples.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)

# Check how our data looks like:
Clustersummary[-c(1:26),] %>%
  kableExtra::kbl(caption = "MetaProViz::mca_core summary of number of metabolites per cluster.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Now we can also create Bargraphs of the clusters to visualize the results. Here we create two summary bargraphs for the Regulation Grouping RG2 and RG3:\
```{r, echo=FALSE}
# Create some summary Bargraphs:
Clustersummary_RG2 <- Clustersummary%>%
  filter(`Regulation Grouping`=="RG2_Significant")%>%
  filter(!`SiRCle cluster Name`=="Background = FALSE")%>%
  filter(!`SiRCle cluster Name`=="None")

Clustersummary_RG3 <- Clustersummary%>%
  filter(`Regulation Grouping`=="RG3_Change")%>%
  filter(!`SiRCle cluster Name`=="Background = FALSE")%>%
  filter(!`SiRCle cluster Name`=="None")

# Barplot for RG2:
Plot_RG2 <- ggplot2::ggplot(Clustersummary_RG2 , ggplot2::aes(fill=`SiRCle cluster Name`, y=`Number of Features`, x=`SiRCle cluster Name`)) +
        ggplot2::geom_bar(stat="identity")+
        ggplot2::theme_classic()+
        ggplot2::scale_fill_manual(values = c("None"="grey" , "Both_UP (Released/Consumed)" = "#9F0162", "Both_DOWN (Released/Consumed)"= "#006384", "Opposite (Consumed DOWN)"="#00735C", "Opposite (Released UP)"="#00422E", "Both_DOWN (Consumed)"= "blue", "core_DOWN (Released/Consumed)"= "lightblue", "core_UP (Released/Consumed)"= "#d03293", "core_UP (Released)"="#630026", "core_DOWN (Consumed)"= "darkblue" ))+
        ggplot2::ggtitle("SiRCle cluster for RG2_Significant")+
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
                       legend.position = "none")+
        ggplot2::labs(x = "SiRCle cluster", y = "Number of Metabolites")

Plot_Sized <-  MetaProViz:::plot_grob_superplot(input_plot=Plot_RG2, metadata_info=c(Conditions="Conditions"), metadata_sample=Clustersummary_RG2%>%dplyr::rename("Conditions"="SiRCle cluster Name"), plot_name = "SiRCle cluster for RG2_Significant", subtitle = NULL, plot_type="Bar")

plot_height <- grid::convertUnit(Plot_Sized$height, 'cm', valueOnly = TRUE)
plot_width <- grid::convertUnit(Plot_Sized$width, 'cm', valueOnly = TRUE)
Plot_Sized %<>%
      {ggplot2::ggplot() + ggplot2::annotation_custom(.)} %>%
       magrittr::add(ggplot2::theme(panel.background = ggplot2::element_rect(fill = "transparent")))

Plot_Sized_RG2 <- Plot_Sized
# ggplot2::ggsave(filename = "Plot_RG2.svg", plot = Plot_Sized_RG2, width = plot_width,  height = plot_height, unit="cm")


# Barplot for RG3:
Plot_RG3 <- ggplot2::ggplot(Clustersummary_RG3 , ggplot2::aes(fill=`SiRCle cluster Name`, y=`Number of Features`, x=`SiRCle cluster Name`)) +
        ggplot2::geom_bar(stat="identity")+
        ggplot2::theme_classic()+
        ggplot2::scale_fill_manual(values = c("None"="grey" , "Both_UP (Released/Consumed)" = "#9F0162", "Both_DOWN (Released/Consumed)"= "#006384", "Opposite (Consumed DOWN)"="#00735C", "Opposite (Released UP)"="#00422E", "Both_DOWN (Consumed)"= "blue", "core_DOWN (Released/Consumed)"= "lightblue", "core_UP (Released/Consumed)"= "#d03293", "core_UP (Released)"="#630026", "core_DOWN (Consumed)"= "darkblue" ))+
        ggplot2::ggtitle("SiRCle cluster for RG3_Change")+
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
                       legend.position = "none")+
        ggplot2::labs(x = "SiRCle cluster", y = "Number of Metabolites")

Plot_Sized <-  MetaProViz:::plot_grob_superplot(input_plot=Plot_RG3, metadata_info=c(Conditions="Conditions"), metadata_sample=Clustersummary_RG3%>%dplyr::rename("Conditions"="SiRCle cluster Name"), plot_name = "SiRCle cluster for RG3_Change", subtitle = NULL, plot_type="Bar")

plot_height <- grid::convertUnit(Plot_Sized$height, 'cm', valueOnly = TRUE)
plot_width <- grid::convertUnit(Plot_Sized$width, 'cm', valueOnly = TRUE)
Plot_Sized %<>%
      {ggplot2::ggplot() + ggplot2::annotation_custom(.)} %>%
       magrittr::add(ggplot2::theme(panel.background = ggplot2::element_rect(fill = "transparent")))

Plot_Sized_RG3 <- Plot_Sized
# ggplot2::ggsave(filename = "Plot_RG3.svg", plot = Plot_Sized_RG3 , width = plot_width,  height = plot_height, unit="cm")

gridExtra::grid.arrange(Plot_Sized_RG2, Plot_Sized_RG3, ncol=2)
```

```{r, eval=FALSE, include=FALSE}
# Input:
Input_Plot <-   Media_Preprocessed%>%
  dplyr::filter(Conditions %in% c("786-M1A", "HK2", "786-O"))%>%
  dplyr::select(-c(1:6))

# Plot Heatmap of each metabolite cluster:
MetaData_Metab_RG2 <- merge(x=DMA_Annova[["Feature_Metadata"]],
                        y=MCA_res[,c(1,14)],
                        by="Metabolite",
                        all.y=TRUE)%>%
   column_to_rownames("Metabolite")


MetaProViz::viz_heatmap(data = Input_Plot,
                       metadata_sample = MetaData_Sample,
                       metadata_info = c(individual_Metab = "RG2_Significant",
                                        color_Sample = list("Conditions"),
                                        color_Metab = list("Pathway", "core_786-M1A", "core_HK2", "core_786-O")),
                       metadata_feature =  MetaData_Metab_RG2,
                      plot_name = "Pathway")

# Plot Superplots:
Metabolite_list <- MetaData_Metab_RG2%>%
  rownames_to_column("Metabolite")%>%
  dplyr::filter(RG2_Significant =="Both_DOWN (Released/Consumed)")%>%
  dplyr::select(Metabolite)%>%
  pull()

MetaProViz::viz_superplot(data =Input_Plot%>%select(all_of(Metabolite_list)) ,#We just plot selected metabolites
                         metadata_sample =MetaData_Sample %>% dplyr::filter(Conditions %in% c("HK2", "786-O", "786-M1A")),
                         metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                         plot_type = "Bar", #Bar, Box, Violin
                         plot_conditions = c("HK2", "786-O", "786-M1A"),#sets the order in which the samples should be plotted
                         stat_comparison = list(c(1,2),c(1,3), c(2,3)))#Stat comparisons to be included on the plot

```

### MetaLinksDB metabolite-receptor and metabolite-transporter sets
The MetaLinks database is a manually curated database of metabolite-receptor and metabolite-transporter sets that can be used to study the connection of metabolites and receptors or transporters [@Farr_Dimitrov2024].\
to remove potential false positives and decrease the number of putative metabolite-receptor interactions, we filter the MetalinksDB resource to metabolites that are annotated as present in the kidney, blood, or urine in HMDB and known to be extracellular.\
```{r}
# Selection as described in ST2 of Farr_Dimitrov2024:
MetaLinksDB <- MetaProViz::metsigdb_metalinks(cell_location =c("Extracellular"),
                                             tissue_location = c("Kidney", "All Tissues"),
                                             biospecimen_location = c("Blood",  "Urine"))

# Here we add a UniquePair column combining hmdb-protein connection, removing duplications originating from different PK resources
MetaLinksDB_Select <- MetaLinksDB %>%
                                           tidyr::unite("UniquePair", c("hmdb", "gene_symbol"), sep = "_", remove=FALSE)%>%
                                           distinct(UniquePair, .keep_all = TRUE)
```
\
Now we can use this information to understand if the metabolites that are consumed in the 786-M1A cells and Released in the HK2 cells are connected to specific receptors or transporters and are in the bioRCM cluster "Both_DOWN (Released/Consumed)\
```{r, echo=FALSE}
MetaLinksDB_BothDOWN <-merge(x=MetaLinksDB_Select,
                                                  y=MCA_res[,c(1,14,48)]%>% dplyr::filter(RG2_Significant=="Both_DOWN (Released/Consumed)") ,
                                                  by.x="hmdb",
                                                  by.y="core_DF_HMDB",
                                                  all.y=TRUE)

# write.csv(MetaLinksDB_BothDOWN, "MetalinksDB_BothDOWN.csv")

# Lets summarise the findings:
message("The following metabolites are not connected to any receptor or transporter in the MetalinksDB: ",
        MetaLinksDB_BothDOWN %>%
          filter(is.na(UniquePair)) %>%
          pull(Metabolite) %>%
          paste(collapse = ", "))

message("The following metabolites are connected to at least one receptor or transporter in the MetalinksDB: ",
        MetaLinksDB_BothDOWN %>%
          filter(!is.na(UniquePair)) %>%
          pull(Metabolite) %>%
          unique() %>%
          paste(collapse = ", "))
```

### ORA on each metabolite cluster
As explained in detail above, Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method. As ORA is based on the Fishers exact test it is perfect to test if a set of features (=metabolic pathways) are over-represented in the selection of features (= clusters of metabolites) from the data in comparison to all measured features (all metabolites). In detail, `MC_ORA()` will perform ORA on each of the metabolite clusters using all metabolites as the background.
```{r, echo=FALSE}
# Check how our data looks like:
MappingInfo[1:6,]%>%
  kableExtra::kbl(caption ="Pathway Input for MetaProViz::MC_ORA.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```

```{r}
MC_ORA_result<- MetaProViz::cluster_ora(data=MCA_core_res[["MCA_core_Results"]]%>%column_to_rownames("Metabolite"),
                                       metadata_info=c(ClusterColumn="RG2_Significant",
                                                        BackgroundColumn="BG_method",
                                                        PathwayTerm= "Pathway", #This is the column name including the pathways names
                                                        PathwayFeature= "Metabolite"),
                                       remove_background=TRUE,
                                       input_pathway=MappingInfo%>%rownames_to_column("Metabolite"),
                                       pathway_name="KEGG",
                                       min_gssize=3,
                                       max_gssize=1000 ,
                                       save_table= "csv")
```
```{r, echo=FALSE}
# Check how our data looks like:
MC_ORA_result[["DF"]][["Both_DOWN (Consumed)"]][c(1:3,7),]%>%
  kableExtra::kbl(caption ="MetaProViz::MC_ORA results for the RG2_Significant cluster `Both_DOWN (Consumed)`.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Here we see that the pathways have a low amount of genes included that were also part of the cluster and the pathways are not significant. This is due to multiple factors, first we only start with a small number of metabolites with KEGG IDs and secondly we only included metabolites if they where detected in both, intracellular and core samples (parameter `method_background="Intra&core"`). Hence, by for example setting parameter `method_background="Intra|core"`, we will obtain larger metabolite clusters.

# 3. Run MetaProViz Visualisation
The big advantages of the `MetaProViz` visualization module is its flexible and easy usage, which we will showcase below and that the figures are saved in a publication ready style and format. For instance, the x- and y-axis size will always be adjusted for the amount of samples or features (=metabolites) plotted, or in the case of Volcano plot and PCA plot the axis size is fixed and not affected by figure legends or title. In this way, there is no need for many adjustments and the figures can just be dropped into the presentation or paper and are all in the same style.\
\
All the `VizPlotName()` functions are constructed in the same way. Indeed, with the parameter `Plot_metadata_info` the user can pass a named vector with information about the metadata column that should be used to customize the plot by colour, shape or creating individual plots, which will all be showcased for the different plot types. Via the parameter `Plot_SettingsFile` the user can pass the metadata DF, which can be dependent on the plot type for the samples and/or the features (=metabolites). In case of both the parameter is named `Plot_metadata_sample` and `Plot_metadata_feature`.\
\
In each of those Plot_Settings, the user can label color and/or shape based on additional information (e.g. Pathway information, Cluster information or other other demographics like gender). Moreover, we also enable to plot individual plots where applicable based on those MetaData (e.g. one plot for each metabolic pathway).\
For this we need a metadata table including information about our samples that could be relevant to e.g. color code:\
```{r}
MetaData_Sample <- Media_Preprocessed[,c(1:2)]%>%
   mutate(Status = case_when(Conditions=="HK2" ~ 'Healthy',
                               TRUE ~ 'Cancer'))
```
```{r, echo=FALSE}
# Check how our data looks like:
MetaData_Sample%>%
  kableExtra::kbl(caption = "Metadata table including additional information about our Samples.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Moreover, we can use MetaData for our features (=Metabolites), which we loaded with the `MappingInfo` and we can also add the information on which cluster a metabolite was assigned to in the `MetaProViz::MCA()` analysis above:\
```{r}
MetaData_Metab <-MappingInfo
```
```{r, echo=FALSE}
# Check how our data looks like:
MetaData_Metab[c(3:4,6,24:26),]%>%
  kableExtra::kbl(caption = "Metadata table including additional information about the Metabolites.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Noteworthy, here we can also use the KEGG pathways we used for the pathway analysis.

### PCA plots
Principal component analysis (PCA) is a dimensionality reduction method that reduces all the measured features (=metabolites) of one sample into a few features in the different principal components, whereby each principal component can explain a certain percentage of the variance between the different samples. Hence, this enables interpretation of sample clustering based on the measured features (=metabolites).\
As mentioned above, PCA plots can be quite useful for quality control, but of course it offers us many more opportunities, which will be showcased here.\
\
As input, we need a DF that contains the samples as rownames and the features (=metabolites) as column names:\
```{r}
Input_PCA <- Media_Preprocessed[,-c(1:4)] #remove columns that include Metadata such as cell type,...
```
```{r, echo=FALSE}
# Check how our data looks like:
Input_PCA[1:6,1:7]%>%
  kableExtra::kbl(caption = "Input_data for `MetaProViz::viz_pca()`, with samples as rownames and metabolites as column names.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Now lets check out the standard plot:
```{r, warning=FALSE, fig.align="left", fig.width=6, fig.height=4.5, fig.cap="Figure: Standard Settings."}
MetaProViz::viz_pca(data=Input_PCA)
```
Next, we can interactively choose shape and color using the additional information of interest from our Metadata. Especially for complex data, such as patient data, it can be valuable to use different demographics (e.g. age, gender, medication,...) for this. First lets check if we have any batch effect by colour coding for the biological replicates, which would be the case if the replicates cluster together.\
```{r, fig.align="left", fig.width=6, fig.height=4.5, fig.cap="Figure: Do we have a batch effect?"}
MetaProViz::viz_pca(metadata_info= c(color="Biological_Replicates"),
                   metadata_sample = MetaData_Sample ,
                   data=Input_PCA,
                  plot_name = "Batch Effect")
```
Given the biological replicates are numeric, we can also set `color_scale` to continuous:
```{r, fig.align="left", fig.width=6, fig.height=4.5, fig.cap="Figure: Do we have a batch effect?"}
MetaProViz::viz_pca(metadata_info= c(color="Biological_Replicates"),
                   metadata_sample = MetaData_Sample ,
                   data=Input_PCA,
                   scale_color = "continuous",
                  plot_name = "Batch Effect (continuous color scale)")
```

Next, we can colour code for condition and use the biological replicates in the shape parameter:\
```{r, fig.align="left", fig.width=6, fig.height=4.5, fig.cap="Figure: Do the samples cluster for the conditions?"}
MetaProViz::viz_pca(metadata_info= c(color="Conditions", shape="Biological_Replicates"),
                   metadata_sample = MetaData_Sample ,
                   data=Input_PCA,
                  plot_name = "Sample Conditions")
```
The different cell lines we have are either control or cancerous, so we can display this too. \
```{r, fig.align="left", fig.width=6, fig.height=4.5, fig.cap="Figure: Do the samples cluster for the Cell status?"}
MetaProViz::viz_pca(metadata_info=  c(color="Status"),
                   metadata_sample = MetaData_Sample ,
                   data=Input_PCA,
                  plot_name = "Sample Status")
```

### Heatmaps
Clustered heatmaps can be useful to understand the patterns in the data, which will be showcased on different examples.\
As input, we need a DF that contains the samples as rownames and the features (=metabolites) as column names:\
```{r}
Input_Heatmap <-   Media_Preprocessed[,-c(1:6)] #remove columns that include Metadata such as cell type,...

# Add consumption-release information of each cell type:
MetaData_Metab <- DMA_Annova[["Feature_Metadata"]]%>%
  column_to_rownames("Metabolite")
```
```{r, echo=FALSE}
# Check how our data looks like:
Input_Heatmap[1:6,1:5]%>%
  kableExtra::kbl(caption = "Input for `MetaProViz::viz_heatmap()`, with samples as rownames and metabolites as column names.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Now we can generate an overview heatmap. Since we plot all metabolites the metabolite names are not plotted since this would get too crowded (You can enforce this by changing the parameter `enforce_featurenames = TRUE`).
```{r, fig.align="left", fig.width=10, fig.height=12, fig.cap="Overview heatmap."}
MetaProViz::viz_heatmap(data = Input_Heatmap,
                      plot_name = "Overview")
```
\
Here we can add as many sample metadata information as needed at the same time:\
```{r, fig.align="left", fig.width=10, fig.height=12, fig.cap="Colour for sample metadata."}
MetaProViz::viz_heatmap(data = Input_Heatmap,
                       metadata_sample = MetaData_Sample,
                       metadata_info = c(color_Sample = list("Conditions","Biological_Replicates", "Status")),
                      plot_name = "Colour Samples")
```
\
Moreover, we can also add metabolite metadata information:\
```{r, fig.align="left",fig.width=12, fig.height=14, fig.cap="Colour for metabolite metadata."}
MetaProViz::viz_heatmap(data = Input_Heatmap,
                       metadata_sample = MetaData_Sample,
                       metadata_info = c(color_Metab = list("Pathway",  "core_786-M1A", "core_HK2", "core_786-M2A", "core_786-O", "core_OSLM1B", "core_OSRC2", "core_RFX631"),
                                        color_Sample = list("Conditions","Biological_Replicates", "Status")),
                       metadata_feature =  MetaData_Metab,
                      plot_name = "Colour Metabolites")
```
\
Lastly, by generate individual plot for e.g. each pathway or the metabolite clusters by adding individual (`individual_Sample` or `individual_Metab`) to `Plot_metadata_info`. At the same time we can still maintain the metadata information for both, the samples and the metabolites. together this can help us to draw biological conclusions about the different pathways: Indeed, we can observe for the `D-Amino acid metabolism` many metabolites fall into the MCA-Cluster `core_DOWN`, meaning in comparison to HK2 cells we have a negative Log2FC for 786-O and 786-M1A.
```{r, eval=FALSE}
# individual: One individual plot for each pathway, col annotation: Colour for samples
MetaProViz::viz_heatmap(data = Input_Heatmap,
                       metadata_sample = MetaData_Sample,
                       metadata_info = c(individual_Metab = "Pathway",
                                        color_Sample = list("Conditions","Biological_Replicates"),
                                        color_Metab = list("core_786-M1A", "core_HK2", "core_786-M2A", "core_786-O", "core_OSLM1B", "core_OSRC2", "core_RFX631")),
                       metadata_feature =  MetaData_Metab,
                      plot_name = "Pathway")

```
<div class="vscroll-plot">
```{r, echo=FALSE, fig.width=9, fig.height=6, warning=FALSE, fig.align="left"}
MetaProViz::viz_heatmap(data = Input_Heatmap,
                       metadata_sample = MetaData_Sample,
                       metadata_info = c(individual_Metab = "Pathway",
                                        color_Sample = list("Conditions","Biological_Replicates"),
                                        color_Metab = list("core_786-M1A", "core_HK2", "core_786-M2A", "core_786-O", "core_OSLM1B", "core_OSRC2", "core_RFX631")),
                       metadata_feature =  MetaData_Metab,
                      plot_name = "Pathway")

```
</div>
\
\
\

You can also choose to make individual plots for any Sample Metadata using `individual_Sample` (e.g. in patients you may want to plot male and female separately). Moreover, you can also use both at the same time.

### Superplots
Sometimes one might be interested to create individual plots for each metabolite to understand the differences between specific conditions. For this common plot types are bargraphs, boxplots or violin plots.
As input, we need a DF that contains the samples as rownames and the features (=metabolites) as column names:\
```{r}
Input_Superplot <-  Media_Preprocessed[,-c(1:4)]#remove columns that include Metadata such as cell type,...
```
```{r, echo=FALSE}
# Check how our data looks like:
Input_Superplot[,1:7]%>%
  kableExtra::kbl(caption = "Input for `MetaProViz::viz_superplot()`, with samples as rownames and metabolites as column names.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
We also need the Metadata as we will need to know which conditions to plot for together. If you have further information such as replicates or patient ID, we can use this for the colour of the plotted samples per condition as in the superplots style as described in by Lord et al [@Lord2020]. \
\
```{r, eval=FALSE}
# Lets select metabolites to plot
metabolite_list <- MCA_res %>%
  filter(stringr::str_detect(RG2_Significant, "Opposite"))%>%
  pull(Metabolite)


MetaProViz::viz_superplot(data =Input_Superplot%>%  select(any_of(metabolite_list)),#We just plot selected metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Bar", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot

```

<div class="vscroll-plot">
```{r, echo=FALSE, warning=FALSE, fig.align="left", fig.width=7, fig.height=5}
metabolite_list <- MCA_res %>%
  filter(stringr::str_detect(RG2_Significant, "Opposite"))%>%
  pull(Metabolite)


MetaProViz::viz_superplot(data =Input_Superplot%>%  select(any_of(metabolite_list)),#We just plot selected metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Bar", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot
```
</div>
\
\
\
Now, if we for instance prefer boxplots over bargraphs we can simply change the parameter `plot_type`:
```{r, eval=FALSE}
MetaProViz:::viz_superplot(data =Input_Superplot[,c(1:6)],#We just plot six metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Box", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot
```

<div class="vscroll-plot">
```{r, echo=FALSE, warning=FALSE, fig.align="left", fig.width=7, fig.height=5}
MetaProViz:::viz_superplot(data =Input_Superplot[,c(1:6)],#We just plot six metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Box", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot
```
</div>
\
\
\
We can also change it to violin plots:
```{r, eval=FALSE}
MetaProViz:::viz_superplot(data =Input_Superplot[,c(1:6)],#We just plot six metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Violin", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot
```

<div class="vscroll-plot">
```{r, echo=FALSE, warning=FALSE, fig.align="left", fig.width=7, fig.height=5}
MetaProViz:::viz_superplot(data =Input_Superplot[,c(1:6)],#We just plot six metabolites
                                           metadata_sample =MetaData_Sample,
                                           metadata_info = c(Conditions="Conditions", Superplot = "Biological_Replicates"),
                                           plot_type = "Violin", #Bar, Box, Violin
                                           plot_conditions = c("HK2", "786-O", "786-M1A", "786-M2A", "OSRC2", "OSLM1B", "RFX631"),#sets the order in which the samples should be plotted
                                           stat_comparison = list(c(1,2),c(1,4)))#Stat comparisons to be included on the plot
```
</div>
\
\
\


### Volcano plot
In general,we have three different `Plot_Settings`, which will also be used for other plot types such as lollipop graphs.\
`1.` `"Standard"` is the standard version of the plot, with one dataset being plotted.\
`2.` `"Conditions"` here two or more datasets will be plotted together. How datasets can be plotted together depends on the plot type.\
`3.` `"PEA"` stands for Pathway Enrichment Analysis, and is used if the results of an GSE analysis should be plotted as here the figure legends will be adapted. You can find an example for this in the vignette `Standard Metabolomics`\
\
Here we will look at all the different options we have to display our results from the different analysis, which will help us to interpret our results as this can be sometimes difficult to do from the many data tables.\
Just a quick reminder, how the input data look like:\
1. Results of Differential Metabolite Analysis (dma): Log2(Distance) and stats:\
```{r, echo=FALSE}
# Check how our data looks like:
DMA_786M1A_vs_HK2[1:7,1:6]%>%
  kableExtra::kbl(caption = "Input_data for `MetaProViz::viz_volcano()` are for example differential analysis results from `MetaProViz::dma()`.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```

#### **Standard**
Here we will first look into the results from the differential analysis (see section `dma` above) for the comparison of `786-M1A_vs_HK2`:
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results."}
# Run with default parameter --> only need to provide Input_data and the title we like
MetaProViz::viz_volcano(data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)")
```
\
If you seek to plot the metabolite names you can change the paramter `select_label` from its default (`select_label=""`) to NULL and the metabolite names will be plotted randomly.
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results."}
# Run with default parameter --> only need to provide Input_data and the title we like
MetaProViz::viz_volcano(data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       select_label = NULL)
```
\
With the parameter `select_label` you can also pass a vector with Metabolite names that should be labeled:
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results."}
# Run with default parameter --> only need to provide Input_data and the title we like
MetaProViz::viz_volcano(data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       select_label = c("histidine", "phenylalanine", "lactate"))
```
\
As explained above, when analyzing core data it is important to take into account if a metabolite is consumed or released. we can use this information to colour code and or shape the metabolites on the plot.\
For this we need to add this information into the Metadata_Metabolite file:
```{r}
# colour for consumption and release: For this we need to add this information into the Metadata_Metabolite file
MetaData_Metab <- merge(MappingInfo%>%rownames_to_column("Metabolite"), DMA_786M1A_vs_HK2[,c(1,6,8:10)], by="Metabolite", all.y=TRUE)%>%
  column_to_rownames("Metabolite")

```
```{r, echo=FALSE}
# Check how our data looks like:
MetaData_Metab[c(3:4,6,24:26),]%>%
  kableExtra::kbl(caption = "Metadata table including additional information about the Metabolites.") %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria", font_size = 12)
```
\
Now we can make the different plots:
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results."}
# Now we need to add our Plot_SettingsFile and the Plot_metadata_info:
MetaProViz::viz_volcano(plot_types="Standard",
                       metadata_info= c(color="core_specific"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A versus HK2",
                       subtitle= "Results of dma. Colour coded for consumption/release" )

# If we want to use the shape instead of the colour for the cluster info, we can just change our Plot_metadata_info
MetaProViz::viz_volcano(plot_types="Standard",
                       metadata_info= c(shape="core_specific"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A versus HK2",
                       subtitle= "Results of dma. Shape for consumption/release, color for significance." )

# Of course, we can also adapt both, color and shape for the same parameter:
MetaProViz::viz_volcano(plot_types="Standard",
                       metadata_info= c(shape="core_specific", color="core_specific"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A versus HK2",
                       subtitle= "Results of dma. Shape and color for consumption/release." )

```
\
Of course, here we may also want an individual plot for each of the consumption/release metabolites.
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results."}
# individual plot for each metabolite behaviour:
MetaProViz::viz_volcano(plot_types="Standard",
                       metadata_info= c(individual="core", shape="core_specific"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A versus HK2",
                       subtitle= "Results of dma." )

```
\
Given that we also know, which metabolic pathway the metabolites correspond to, we can add this information into the plot. This is also a good example to showcase the flexibility of the visualisation function: Either you use the parameter `Plot_SettingsFile= MetaData_Metab` as above, but as we have the column "Pathway" also in our Input_data you can also pass `Plot_SettingsFile= DMA_786-M1A_vs_HK2` or simply use the default `Plot_SettingsFile=NULL`, in which case the `Plot_metadata_info` information (here `color`) will be used from Input_data. \
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying dma results colour coded for metabolic pathways and shaped for metabolic clusters."}
# Now we can use color for the pathways and shape for the metabolite clusters:
MetaProViz::viz_volcano(plot_types="Standard",
                       metadata_info= c(individual="core", shape="core_specific", color="Pathway"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A versus HK2",
                       subtitle= "Results of dma." )
```


#### **Comparison**
The parameter `Plot_Settings="Compare"` is helpful if you have performed multiple comparisons and seek to compare two of them in one plot:\
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Comparison."}
# Make the plot
MetaProViz::viz_volcano(plot_types="Compare",
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       data2= DMA_Annova[["dma"]][["786-O_vs_HK2"]]%>%column_to_rownames("Metabolite"),
                       name_comparison= c(data="786M1A_vs_HK", data2= "786-O_vs_HK2"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A vs HK2 compared to 7860 vs HK2",
                       subtitle= "Results of dma" )
```
\
Of course you have option to use shape or color to further customize your graph as well as make individual plots:\
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Comparison."}
# Make the plot
MetaProViz::viz_volcano(plot_types="Compare",
                       metadata_info= c(color="Pathway"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       data2= DMA_Annova[["dma"]][["786-O_vs_HK2"]]%>%column_to_rownames("Metabolite"),
                       name_comparison= c(data="786M1A_vs_HK", data2= "786-O_vs_HK2"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A vs HK2 compared to 7860 vs HK2",
                       subtitle= "Results of dma" )
```

Now we do individual plots again:
```{r, eval=FALSE}
MetaProViz::viz_volcano(plot_types="Compare",
                       metadata_info= c(individual="Pathway"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       data2= DMA_Annova[["dma"]][["786-O_vs_HK2"]]%>%column_to_rownames("Metabolite"),
                       name_comparison= c(data="786M1A_vs_HK", data2= "786-O_vs_HK2"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A vs HK2 compared to 7860 vs HK2",
                       subtitle= "Results of dma" )
```

<div class="vscroll-plot">
```{r, echo=FALSE,warning=FALSE, fig.align="left", fig.width=7, fig.height=5}
MetaProViz::viz_volcano(plot_types="Compare",
                       metadata_info= c(individual="Pathway"),
                       metadata_feature= MetaData_Metab,
                       data=DMA_786M1A_vs_HK2%>%column_to_rownames("Metabolite"),
                       data2= DMA_Annova[["dma"]][["786-O_vs_HK2"]]%>%column_to_rownames("Metabolite"),
                       name_comparison= c(data="786M1A_vs_HK", data2= "786-O_vs_HK2"),
                       x= "Log2(Distance)",
                       plot_name= "786M1A vs HK2 compared to 7860 vs HK2",
                       subtitle= "Results of dma" )
```
</div>
\
\

#### **PathwayEnrichmentAnalysis**
If you have performed Pathway Enrichment Analysis (PEA) such as ORA or GSEA, we can also plot the results and add the information into the Figure legends.\
Here we can for example use the results of the ORA we have performed on the differential expression results. Indeed for DMA_786M1A_vs_HK2 we have performed ORA on each cluster (consumed, released, consumed/released). Here, I will plot the ORA results of the metabolites that are released in both conditions, HK2 and 786-M1A.
```{r}
# Prepare the Input:
# 1. data=Pathway analysis input: Must have features as column names. Those feature names need to match features in the pathway analysis file metadata_feature.
InputPEA <- DMA_786M1A_vs_HK2 %>%
  filter(!is.na(KEGGCompound)) %>%
  column_to_rownames("KEGGCompound")

# 2. data2=Pathway analysis output: Must have same column names as metadata_feature for Pathway name
InputPEA2 <- MC_ORA_786M1A_vs_HK2_Consumed %>%
  dplyr::rename("term"="ID")

# 3. metadata_feature= Pathways used for pathway analysis: Must have same column names as metadata_feature for Pathway name and feature names need to match features in the data. PEA_Feature passes this column name!

```
\
```{r, eval=FALSE}
MetaProViz::viz_volcano(plot_types="PEA",
                       metadata_info= c(PEA_Pathway="term",# Needs to be the same in both, metadata_feature and data2.
                                       PEA_stat="p.adjust",#Column data2
                                       PEA_score="GeneRatio",#Column data2
                                       PEA_Feature="Metabolite"),# Column metadata_feature (needs to be the same as row names in data)
                       metadata_feature= KEGG_Pathways,#Must be the pathways used for pathway analysis
                       data= InputPEA, #Must be the data you have used as an input for the pathway analysis
                       data2= InputPEA2, #Must be the results of the pathway analysis
                       x= "Log2(Distance)",
                       plot_name= "KEGG",
                       subtitle= "PEA" ,
                       select_label = NULL)
```

<div class="vscroll-plot">
```{r, echo=FALSE, warning=FALSE, fig.align="left", fig.width=7, fig.height=5}
MetaProViz::viz_volcano(plot_types="PEA",
                       metadata_info= c(PEA_Pathway="term",# Needs to be the same in both, metadata_feature and data2.
                                       PEA_stat="p.adjust",#Column data2
                                       PEA_score="GeneRatio",#Column data2
                                       PEA_Feature="Metabolite"),# Column metadata_feature (needs to be the same as row names in data)
                       metadata_feature= KEGG_Pathways,#Must be the pathways used for pathway analysis
                       data= InputPEA, #Must be the data you have used as an input for the pathway analysis
                       data2= InputPEA2, #Must be the results of the pathway analysis
                       x= "Log2(Distance)",
                       plot_name= "KEGG",
                       subtitle= "PEA" ,
                       select_label = NULL)
```

</div>
\
\
<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>



# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessionInfo()
```

---
#title: "**MetaProViz**"
#author: "Authors: Christina Schmidt, Dimitrios"
#date: "24 November 2022"
output:
   html_document:
    #yml: _site.yml
    css: style.css
    theme: flatly
    highlight: tango #`default`, `tango`, `pygments`, `kate`, `monochrome`, `espresso`, `zenburn`, `haddock`, `breezedark`, `textmate`, `arrow`, or `rstudio`
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 4
    code_folding: show
#vignette: >
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteIndexEntry{MetaProViz}
#  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

\
<a href="#" class="btn btn-link">[**Browse source code**](https://github.com/ChristinaSchmidt1)</a>
<a href="#" class="btn btn-link">[**View on Bioconductor**](https://github.com/ChristinaSchmidt1)</a>
<a href="#" class="btn btn-link">[**Citing MetaProViz**](https://github.com/ChristinaSchmidt1)</a>
<a href="#" class="btn btn-link">[**FrezzaLab**](https://twitter.com/FrezzaLab)</a>
<a href="#" class="btn btn-link">[**SaezLab**](https://twitter.com/saezlab)</a>

<style>
.vscroll-plot {
    width: 1000px;
    height: 500px;
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

# Standard metabolomics

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

A standard metabolomics experiment refers to intracellular extracts (e.g. cell or bacteria culture), to tissue samples (e.g. from animals or patients), to plasma samples (e.g. blood) and many other types of experimental setups.\
\
<span style="text-decoration:underline">In this tutorial we showcase how to use **MetaProViz**</span>:\
`-` To process raw peak data and identify outliers.\
`-` To perform differential metabolite analysis (DMA) to generate Log2FC and statistics and perform pathway analysis using Over Representation Analysis (ORA) on the results.\
`-` To do metabolite clustering analysis (MCA) to find clusters of metabolites with similar behaviors and perform pathway analysis using ORA on each cluster.\
`-` To use specific visualizations to aid biological interpretation of the results.\
\
\
First if you have not done yet, install the required dependencies and load the libraries:
```{r message=FALSE, warning=FALSE}
#MetaProViz

#library(MetaProViz)
devtools::load_all("C:/Users/chris/Documents/GitHub/MetaProViz")#only loaded until package is online

#dependencies
library(tidyverse)

```
\
\
<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

# 1. Loading the example data

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

Here we choose an example datasets, which is publicly available on [metabolomics workbench project PR001418](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Project&ProjectID=PR001418) including metabolic profiles of human renal epithelial cells HK2 and cell renal cell carcinoma (ccRCC) cell lines cultured in Plasmax cell culture media. Here we use the integrated raw peak data as example data using the trivial metabolite name in combination with the KEGG ID as the metabolite identifiers.\
\
<span style="text-decoration:underline">As part of the **MetaProViz** package you can load the example data into your global environment using the function `toy_data()`</span>:\
\
`1.` Intracellular experiment **(Intra)** \
The raw data are available via [metabolomics workbench study ST002224](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Study&StudyID=ST002224&StudyType=MS&ResultType=1) were intracellular metabolomics of HK2 and ccRCC cell lines 786-O, 786-M1A and 786-M2A were performed.\
```{r}
MetaProViz::toy_data(data="Standard")

# Check how our data looks like:
knitr::kable(Intra[1:5, 1:7], caption = "Preview of the DF `Intra` including columns with sample information and metabolite ids with their measured values.")
```
\
We will split the experimental data into the sample information and the metabolites values using the the column "Code" as the unique identifier:
```{r}
Intra_M <- Intra[1:47,-c(2:4)]%>%
  column_to_rownames("Code")

SampleInfo <-Intra[c(1:47),c(1:4)]%>%
  column_to_rownames("Code")

```
\
`2.` Additional information mapping the trivial metabolite names to KEGG IDs and selected pathways **(MappingInfo)** \
```{r}
MetaProViz::toy_data(data="MappingInfo")

# Check how our data looks like:
knitr::kable(MappingInfo[1:5,], caption = "Preview of the DF `Pathways` including the trivial metabolite identifiers used in the experiment as well as KEGG IDs and pathway information.")
```
\
`3.` KEGG pathways that are loaded via KEGG API using the package `KEGGREST` and can be used to perform pathway analysis. **(KEGG_Pathways)**\
```{r}
#This will use KEGGREST to query the KEGG API to load the pathways:
MetaProViz::Load_KEGG()

# Check out how this looks:
knitr::kable(KEGG_Pathways[1:5,], caption = "Preview of the DF `KEGG_Pathways`.")
```
\
\
<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 550%"></div>
</div>

# 2. Run MetaProViz Analysis

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 550%"></div>
</div>

Currently, **MetaProViz** contains four different modules, which include different methods and can be used independently from each other or in combination (see introduction for more details). Here we will go trough each of those modules and apply them to the example data.

## Pre-processing
**MetaProViz** includes a pre-processing module with the function `Preprocessing()` that has multiple parameters to perform customize data processing.\
`Feature_Filtering` applies the 80%-filtering rule on the metabolite features either on the whole dataset (="Standard") (Bijlsma S. et al., 2006) or per condition (="Modified") (Yang, J et al., 2015). This means that metabolites are removed were more than 20% of the samples (all or per condition) have no detection. With the parameter `Feature_Filt_Value` we enable the adaptation of the stringency of the filtering based on the experimental context. For instance, patient tumour samples can contain many unknown subgroups due to gender, age, stage etc., which leads to a metabolite being detected in only 50% (or even less) of the tumour samples, hence in this context it could be considered to change the `Feature_Filt_Value` from the default (=0.8). If `Feature_Filtering = "None"`, no feature filtering is performed. In the context of `Feature_Filtering` it is also noteworthy that the function `Pool_Estimation()` can be used to estimate the quality of the metabolite detection and will return a list of metabolites that are variable across the different pool (mixture of all experimental samples measured several times during the LC-MS run) measurements and hence the quality of the detection is pool and hence the metabolite should be removed from the data.\
The paramteter `TIC_Normalization` refers to Total Ion Count (TIC) normalisation, which is often used with LC-MS derived metabolomics data. If `TIC_Normalization = TRUE`, each feature (=metabolite) in a sample is divided by the sum of all intensity value (= total number of ions)  for the sample and finally multiplied by a constant ( = the mean of all samples total number of ions). Noteworthy, TIC normalisation should not be used with small number of features (= metabolites), since TIC assumes that on “average” the ion count of each sample is equal if there were no instrument batch effects (Wulff et. al., (2018)).\
The parameter `MVI` refers to Missing Value Imputation (MVI) and if `MVI = TRUE` half minimum (HM) missing value imputation is performed per feature (= per metabolite). Here it is important to mention that HM has been shown to perform well for missing vales that are missing not at random (MNAR) (Wei et. al., 2018 ,https://www.nature.com/articles/s41598-017-19120-0).\
Lastly, the function `Preprocessing()` performs outlier detection and adds a column "Outliers" into the DF, which can be used to remove outliers. The parameter `HotellinsConfidence` can be used to choose the confidence interval that should be used for the Hotellins T2 outlier test (Hotelling, H., 1931, doi:https://doi.org/10.1214/aoms/1177732979.).\

Notes on MVI: 
- Wei quantile regression imputation of left-censored data (QRILC) as performing best even though HM performs better in some of their tests and quantile normalisation would not work well for normal distribution!
- Show MVI results with different percentages (not just 50% as per half minimum!) --> implement parameter for user to change?!
- Show that per feature imputation is advantageous over the "standard" imputation --> change standard to per feature!
- Check out QRILC and see if its the same as in  proDA (https://www.bioconductor.org/packages/release/bioc/html/proDA.html) 
\
Since our example data contains pool samples, we will do `Pool_Estimation()` before applying the `Preprocessing()` function. This is important, since one should remove the features (=metabolites) that are too variable prior to performing any data transformations such as TIC as part of the `Preprocessing()` function.\
```{r}
#Get the Pool data
PoolData <- MetaProViz::toy_data(data="Standard")%>%
  subset(Conditions=="Pool", select = -c(2:4))# we remove the columns "Conditions", "Analytical_Replicates" and "Biological_Replicates"

  

#--> remove features if needed.
```
\
Now we will apply the `Preprocessing()` function to example data and have a look at the output produced. You will notice that all the chosen parameters and results are documented in messages. All the results data tables, the Quality Control (QC) plots and outlier detection plots are returned to the global environment and can be easily viewed.\
```{r}
MetaProViz::Preprocessing(Input_data=Intra_M,
                          Experimental_design=SampleInfo,
                          Feature_Filtering = "Modified",
                          Feature_Filt_Value = 0.8,
                          TIC_Normalization = TRUE,# As we have raw data we will perform total ion count normalisation
                          MVI=TRUE, #We assume the values are not missing at random and perform half minimum missing value imputation
                          HotellinsConfidence = 0.99,# We perform outlier testing using 0.99 confidence intervall
                          ExportQCPlots = TRUE,
                          CoRe = FALSE,# as we have a standard experiment and not a Consumption-Release (CoRe) experiment we set this to FALSE
                          Save_as = "svg") 

# Now we can have a look at the results table:
Intra_Preprocessed <- PreProcessing_res[["Processed_data"]]

knitr::kable(Intra_Preprocessed[29:32, 1:9]%>%rownames_to_column("Code"), caption = "Preview of the pre-processing results, which has an additional column `Outlier` including the results of Hotellins T2.", row.names=FALSE)

```
\
In the output table you can now see the column "Outliers" and for the Condition 786-M2A, we can see that based on Hotellin's T2 test, one sample was detected as an outlier in the first round of filtering.\
As part of the `Preprocessing()` function several plots are generated, returned to the environment and saved. Those include the `Outlier_Plots`, which we can further check for the outlier:\
```{r}
#For each Round of HotellinsT2 test three plots will be saved:
#1.PCA plot
P1 <- Outlier_Plots[[1]]
P1

#2.Screeplot
P2 <- Outlier_Plots[[2]]
P2
#3.Hotellins Outlier
P3 <- Outlier_Plots[[3]]
P3

################### 
#If there has been an outlier detected, it will be removed and the HotellinsT2 test is repeated. 
#Here a second round was performed and the plots saved:
P4<- Outlier_Plots[[4]]
P4
P5<- Outlier_Plots[[5]]
P5
P6<- Outlier_Plots[[6]]
P6
```
I have a list with 6 elements, each of them being a plot. If I run `Outlier_Plots[[3]]` in the console , I will see the plot. Yet, if I knite the .rmd file I will only see `Outlier_Plots[[1]]`, not the others.
--> Maybe try gridextra:
library(gridExtra)
library(grid)
grid.arrange(Outlier_Plots, ncol=2)
--> general coding chanel
\
The QC plots `QC_Plots` include an PCA plot using the processed data and highlighting the outliers. Moreover, if one has provided information about biological replicates a second plot is generated highlighting the biological replicates, which would highlight if there is a batch effect.\
```{r}
# PCA plot
# 1. Marked Outliers:
Q1 <- QC_Plots[[1]]
Q1

#2. Marked Biological replicates:
Q2 <- QC_Plots[[2]]
Q2
```
\
As part of the **MetaProViz** visualization module one can easily customize the PCA plot and adapt color and shape for the information of interest. You can see more below for the `VizPCA()` function.
\
Before we proceed, we will remove the outlier:\
```{r}
Intra_Preprocessed <- Intra_Preprocessed[-29,]#remove MS55_29
```
\
As you may have noticed, in this example dataset we have several biological replicates that where injected (=measured) several times, which can be termed as analytical replicates. The **MetaProViz** pre-processing module includes the function `ReplicateSum()`, which will do this task and save the results:\
```{r}
Intra_Preprocessed <- MetaProViz::ReplicateSum(Input_data=Intra_Preprocessed)
```
\
Using the pre-processed data, we can now use the **MetaProViz** visualization module and generate some overview Heatmaps `VizHeatmap()` or PCA plots `VizPCA()`. You can see some examples below. 

## DMA
Differential Metabolite Analysis (`DMA`) between two conditions (e.g. Tumour versus Healthy) calculates the Log2FC, p-value, adjusted p-value and t-value. With the different parameters of the `DMA()` function one can choose the statistical tests to calculate the p-value and adjusted p-value (parameters `STAT_pval` and `STAT_padj`).\
As input we will use the  pre-processed data we have generated using the `Preprocessing` module, but here one can of course use any DF including metabolite values and information about the conditions that should be compared (even though we recommend to normalize the data and remove outliers prior to DMA). Noteworthy, if you have not performed missing value imputation and hence you data includes NAs or 0 values for some features, this will be taken into account in the `DMA()` function:\
`1.` If all values of the replicates of one condition are NA/0 for a feature (=metabolite): Log2FC= Inf/-Inf and the statistics will be NA\
`2.` If some values  of the replicates of one condition are NA/0 for a feature (=metabolite): Log2FC= positive or negative value, but the statistics will be NA\
\
In the example data we have four different cell lines, healthy (HK2) and cancer (ccRCC: 786-M1A, 786-M2A and 786-O) and hence we can perform multiple different comparisons. The results are automatically saved and returned into the global environment. If parameter Plot=TRUE, an overview Volcano plot is generated and saved.\
```{r}
MetaProViz::DMA(Input_data=Intra_Preprocessed[,-c(1:3)], #we need to remove columns that do not include metabolite measurements
               Experimental_design=Intra_Preprocessed[,c(1:2)],#only maintain the information about condition and replicates
               Condition1="HK2",
               Condition2="786-O",
               STAT_pval ="t.test",#ProDA is another test! --> estimates missing information
               STAT_padj="fdr",
               Input_Pathways = MappingInfo[,c(1,4)], 
               OutputName='DMA_HK2v786O', 
               CoRe=FALSE, 
               Plot = TRUE, 
               Save_as = "svg")

# Check how our data looks like:
knitr::kable(`DMA_HK2_vs_786-O`[1:6,], caption = "Preview of the DMA results for the comparison of HK2 versus 786-O cells.", row.names=FALSE)

#Perform the other comparisons:
MetaProViz::DMA(Input_data=Intra_Preprocessed[,-c(1:3)], 
               Experimental_design=Intra_Preprocessed[,c(1:2)],
               Condition1="HK2",
               Condition2="786-M1A",
               STAT_pval ="t.test",
               STAT_padj="fdr",
               Input_Pathways = MappingInfo[,c(1,4)], 
               OutputName='DMA_HK2v786M1A', 
               CoRe=FALSE, 
               Plot = TRUE, 
               Save_as = "svg")

MetaProViz::DMA(Input_data=Intra_Preprocessed[,-c(1:3)], 
               Experimental_design=Intra_Preprocessed[,c(1:2)],
               Condition1="HK2",
               Condition2="786-M2A",
               STAT_pval ="t.test",
               STAT_padj="fdr",
               Input_Pathways = MappingInfo[,c(1,4)], 
               OutputName='DMA_HK2v786M2A', 
               CoRe=FALSE, 
               Plot = TRUE, 
               Save_as = "svg")


# For timeseries: anova test, cruckal walles.--> multiple groups! pearson correlation (use limma)

```
\
Using the DMA results, we can now use the **MetaProViz** visualization module and generate customized Volcano plots `VizVolcano()` or Lollipop graphs `VizLollipop()`. You can see some examples below. 

### ORA using the DMA results
Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method that determines if a set of features (=metabolic pathways) are over-represented in the selection of features (=metabolites) from the data in comparison to all measured features (metabolites) using the Fishers exact test. The selection of metabolites are usually the most altered metabolites in the data, which can be selected by the top and bottom t-values.\
Of course, there are many other PEA methods such as the well known GSEA. Here we do not aim to provide an extensive tool for different methods to perform pathway enrichment analysis and only focus on ORA since we can apply this to perform standard pathway enrichment as well as pathway enrichment on clusters of metabolites (see MCA below). If you are interested in using different pathway enrichment methods please check out specialized tools such as [decopupleR](https://saezlab.github.io/decoupleR/).\
\
Here we will use the KEGG pathways. Before we can perform ORA on the DMA results, we have to ensure that the metabolite names match with the KEGG IDs or KEGG trivial names. In general, the `PathwayFile` requirements are column "term", "Metabolite" and "Description", and the `Input_data` requirements are column "t.val" and column "Metabolite".\
```{r}
############ 1. Ensure that the Metabolite names match with KEGG IDs or KEGG trivial names. 
#Input data requirements: column `t.val` and column `Metabolite`
#We use the KEGG-IDs to match, yet we prefer the trivial names
#Here we use the MappingInfo file
HK2_vs_786M1A <- merge(`DMA_HK2_vs_786-M1A`[,1:5],MappingInfo[1:3], by="Metabolite", all=TRUE)
HK2_vs_786M1A <-HK2_vs_786M1A[complete.cases(HK2_vs_786M1A),-1]%>%
  dplyr::rename("Metabolite"=6)

HK2_vs_786M2A <- merge(`DMA_HK2_vs_786-M2A`[,1:5], MappingInfo[1:3], by="Metabolite", all=TRUE)
HK2_vs_786M2A <-HK2_vs_786M2A[complete.cases(HK2_vs_786M2A),-1]%>%
  dplyr::rename("Metabolite"=6)

HK2_vs_786O <- merge(`DMA_HK2_vs_786-O`[,1:5], MappingInfo[1:3], by="Metabolite", all=TRUE)
HK2_vs_786O <-HK2_vs_786O[complete.cases(HK2_vs_786O),-1]%>%
  dplyr::rename("Metabolite"=6)

# Above we loaded the Kegg_Pathways using MetaProViz::Load_KEGG()
#Pathway file requirements: column `term`, `Metabolite` and `Description`
ORA_HK2_vs_786M1A <- MetaProViz::DM_ORA(Input_data=HK2_vs_786M1A,
                   PathwayFile=KEGG_Pathways[,-3],
                   PathwayName="KEGG",
                   minGSSize=3,
                   maxGSSize=1000 ,
                   Save_as="svg",
                   pCutoff=1,
                   PercentageCutoff=1)

ORA_HK2_vs_786M2A <- MetaProViz::DM_ORA(Input_data=HK2_vs_786M2A,
                   PathwayFile=KEGG_Pathways[,-3],
                   PathwayName="KEGG",
                   minGSSize=3,
                   maxGSSize=1000 ,
                   Save_as="svg",
                   pCutoff=1,
                   PercentageCutoff=1)

ORA_HK2_vs_786O <- MetaProViz::DM_ORA(Input_data=HK2_vs_786O,
                   PathwayFile=KEGG_Pathways[,-3],
                   PathwayName="KEGG",
                   minGSSize=3,
                   maxGSSize=1000 ,
                   Save_as="svg",
                   pCutoff=1,
                   PercentageCutoff=1)

```

## MCA
Metabolite Clustering Analysis (`MCA`) is a module, which includes different functions to enable clustering of metabolites into groups either based on logical regulatory rules or based on kmeans clustering. This can be particularly useful if one has multiple conditions and aims to find patterns in the data.

### MCA-2Cond

Refer to SiRCle and mention sircle concept that was adapted here! --> add the citation to function?

To Do:
- Create Figure (alluvial plot) explaining the general concept --> usable for manuscript as well
```{r}
#Example of all possible flows:
MetaProViz::MCA_rules(data="2Cond")


# Check how our data looks like:
knitr::kable(MCA_2Cond, caption = "Metabolite Clustering Analysis: 2 Conditions.", row.names=FALSE)

#easyalluvial --> update allulvial plot package used to this one!

easyalluvial::alluvial_wide(MCA_2Cond[,c(1:2,4)], fill_by = 'last_variable' )

easyalluvial::alluvial_wide(MCA_2Cond[,c(1:2,5)], fill_by = 'last_variable' )

```

Now let's use the data and do clustering:
```{r}
MCAres <- MetaProViz::MCA_2Cond(Cond1_File=`DMA_HK2_vs_786-O`,
                      Cond2_File=`DMA_HK2_vs_786-M1A`,
                      MetaboliteID= "Metabolite",
                      Cond1ValueCol="Log2FC",
                      Cond1PadjCol="p.adj",
                      Cond2ValueCol="Log2FC",
                      Cond2PadjCol="p.adj",
                      Cond1_padj_cutoff= 0.05,
                      Cond2_padj_cutoff = 0.05,
                      Cond1_FC_cutoff= 1,
                      Cond2_FC_cutoff = 1,
                      backgroundMethod="C1&C2",
                      OutputFileName = "MCA_2Cond")


# Check how our data looks like:
knitr::kable(Summary_MCA_2Cond , caption = "Summary of MCA: 2 Conditions.", row.names=FALSE)

```

### MCA-Kmeans
Next lets try kmeans clustering:
```{r}

```

### ORA on each metabolite cluster
As explained in detail above, Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method. As ORA is based on the Fishers exact test it is perfect to test if a set of features (=metabolic pathways) are over-represented in the selection of features (= clusters of metabolites) from the data in comparison to all measured features (all metabolites). In detail, `MC_ORA()` will perform ORA on each of the metabolite clusters using all metabolites as the background.

To Do:
- (discuss to remove the metabolites that are not in background, which can happen in the two-cond, not for kmeans though)
- Here change function and just plot emapplot and upset if there is a minimum of two pathways!

```{r}

PathwayInput <- MappingInfo[,c(1,4)]%>%
  rename("term"="Pathway")
PathwayInput$Description <- PathwayInput$term

# Check how our data looks like:
knitr::kable(PathwayInput[1:5,] , caption = "Summary of MCA: 2 Conditions.", row.names=FALSE)

```


```{r, eval=FALSE}
MetaProViz::MC_ORA(Input_data=MCAres,
                   MetabCluster_lab="RG2_Significant",
                   RemoveBackground=TRUE,
                   PathwayFile=PathwayInput,
                   PathwayName="Selfmade",
                   minGSSize=3,
                   maxGSSize=1000 ,
                   Save_as="svg",
                   pCutoff=0.2,
                   PercentageCutoff=10
                   )
```

<div class="vscroll-plot">
```{r, echo=FALSE, fig.align="left", fig.width=8, fig.height=5}
MetaProViz::MC_ORA(Input_data=MCAres,
                   MetabCluster_lab="RG2_Significant",
                   RemoveBackground=TRUE,
                   PathwayFile=PathwayInput,
                   PathwayName="Selfmade",
                   minGSSize=3,
                   maxGSSize=1000 ,
                   Save_as="svg",
                   pCutoff=0.2,
                   PercentageCutoff=10
                   )
```
</div>
\
\

# 3. Run MetaProViz Visualisation
In general, each of the different plot types (e.g. Volcano plot, Lollipop graph,...) have 3 main `Plot_Settings`.\
`1.` `"Standard"` is the standard version of the plot, with one dataset being plotted.
`2.` `"Conditions"` here two or more datasets will be plotted together. How datasets can be plotted together depends on the plot type.\
`3.` `"PEA"` stands for Pathway Enrichment Analysis, and is used if the results of an GSE analysis should be plotted as here the figure legends will be adapted.\
\
In each of those Plot_Settings, the user can label color and/or shape based on additional information (e.g. Pathway information, Cluster information or other other demographics like gender). Moreover, we also enable to plot individual plots where applicable based on additional information (e.g. one plot for each metabolic pathway).

### PCA plots
Principal component analysis (PCA) is a dimensionality reduction method that reduces all the measured features (=metabolites) of one sample into a few features in the different prinipal components, whereby each principal component can explain a certain percentage of the variance between the different samples. Hence, this enables interpretation of sample clustering based on the measured features (=metabolites).\
As mentioned above, PCA plots can be quite useful for quality control, but of course it offers us many more oppotunities, which will be showcased here.\
\
The input data must contain a column called "UniqueID" and otherwise only contain numeric columns with the measurements for each metabolite.\
```{r}
#Make column "UniqueID"
Input_PCA <- Intra_Preprocessed[,-c(1:3)]%>%
  rownames_to_column("UniqueID")

# Check how our data looks like:
knitr::kable(Input_PCA[,1:6] , caption = "Input_data for VizPCA must contain a column called `UniqueID` and numeric values for metabolites.", row.names=FALSE)

#Plot:
MetaProViz::VizPCA(Input_data=Input_PCA)
```
\
Of course, now we can interactively choose shape and color using additional information of interest. Especially for complex data such as patient data it can be valuable to use different demographics (e.g. age, gender, medication,...) for this.
```{r}
#Make a Settings file:
Settings_PCA <- Intra_Preprocessed[,c(1:2)]%>%
  rownames_to_column("UniqueID")%>%
   mutate(Celltype = case_when(Conditions=="HK2" ~ 'Healthy',
                               Conditions=="786-O" ~ 'Primary Tumour',
                               TRUE ~ 'Metastatic Tumour'))%>%
   mutate(Status = case_when(Conditions=="HK2" ~ 'Healthy',
                               TRUE ~ 'Cancer'))
# Check how our data looks like:
knitr::kable(Settings_PCA , caption = "Different information that can be used for colour or shape.", row.names=FALSE)
```

First lets check if we have any batch effect by colour coding for the biological replicates, which would be the case if the replicates cluster together.\
```{r, fig.align="left", fig.width=8, fig.height=5, fig.cap="Figure: Do we have a batch effect?"}
MetaProViz::VizPCA(Plot_SettingsInfo= c(color="Biological_Replicates"),
                   Plot_SettingsFile= Settings_PCA ,
                   Input_data=Input_PCA,
                   OutputPlotName = "Batch Effect")
```
\
Next, we can colour code for condition and use the replicates in the shape parameter:\
```{r, fig.align="left", fig.width=8, fig.height=5, fig.cap="Figure: Do the samples cluster for the conditions?"}
MetaProViz::VizPCA(Plot_SettingsInfo= c(color="Conditions", shape="Biological_Replicates"),
                   Plot_SettingsFile= Settings_PCA ,
                   Input_data=Input_PCA,
                   OutputPlotName = "Sample Conditions")
```
\
The different cell lines we have are either control or cancerous, so we can display this too. Here is becomes apparent that the cell status is responsible for 64% of the variance (x-axis). \
```{r, fig.align="left", fig.width=8, fig.height=5, fig.cap="Figure: Do the samples cluster for the Cell status?"}
MetaProViz::VizPCA(Plot_SettingsInfo= c(color="Status"),
                   Plot_SettingsFile= Settings_PCA ,
                   Input_data=Input_PCA,
                   OutputPlotName = "Sample Status")
```
\
We can separate the cancerous cell lines further into metastatic or primary. This shows us that this is separated on the y-axis and accounts for 30%of the variance.\
```{r, fig.align="left", fig.width=8, fig.height=5, fig.cap="Figure: Do the samples cluster for the Cell type?"}
MetaProViz::VizPCA(Plot_SettingsInfo= c(color="Celltype", shape="Status"),
                   Plot_SettingsFile= Settings_PCA ,
                   Input_data=Input_PCA,
                   OutputPlotName = "Cell type")
```
\
Lastly, its worth mentioning that one can also change many style parameters to customize the plot:\
```{r, fig.align="left", fig.width=8, fig.height=5}
MetaProViz::VizPCA(Plot_SettingsInfo= c(color="Celltype", shape="Status"),
                   Plot_SettingsFile= Settings_PCA ,
                   Input_data=Input_PCA,
                   color_palette= NULL,#pass your own colour palette
                   shape_palette=NULL,#pass your own shape palette
                   Show_Loadings = TRUE, #show laodings (default=FALSE)
                   Scaling = TRUE, #use scaling?
                   Theme=theme_gray(),#theme_classic() is default, use any: https://ggplot2.tidyverse.org/reference/ggtheme.html
                   OutputPlotName= 'Cell type',
                   Save_as = "svg")
```

### Heatmaps

```{r}
#Standard
Heatmap_data <-  Intra_Preprocessed[,-c(1:3)]
Heatmap_design <- Intra_Preprocessed[,c(1:2)]%>%
   mutate(Celltype = case_when(Conditions=="HK2" ~ 'Healthy',
                               Conditions=="786-O" ~ 'Primary Tumour',
                               TRUE ~ 'Metastatic Tumour'))%>%
   mutate(Status = case_when(Conditions=="HK2" ~ 'Healthy',
                               TRUE ~ 'Cancer'))

#Standard
MetaProViz::VizHeatmap(Input_data = Heatmap_data, 
                       OutputPlotName = "Standard",
                       Save_as = "pdf")


```

```{r}

# col annotation
MetaProViz::VizHeatmap(Input_data = Heatmap_data,
                       Plot_SettingsFile_Sample = Heatmap_design,
                       Plot_SettingsInfo = c(color_Sample = list("Conditions","Biological_Replicates", "Celltype", "Status")),
                       OutputPlotName = "Colour Samples")

# row annotation
MetaProViz::VizHeatmap(Input_data = Heatmap_data,
                       Plot_SettingsFile_Sample = Heatmap_design,
                       Plot_SettingsInfo = c(color_Metab = list("Pathway")),
                       Plot_SettingsFile_Metab =  MappingInfo, 
                       OutputPlotName = "Colour Metabolites")
```
```{r}
# individual
MetaProViz::VizHeatmap(Input_data = Heatmap_data,
                       Plot_SettingsFile_Sample= Heatmap_design,
                       Plot_SettingsInfo = c(individual = "Pathway"),
                       Plot_SettingsFile_Metab =  MappingInfo,
                       OutputPlotName = "Pathways")


# individual with col and row annotation
MetaProViz::VizHeatmap(Input_data = Heatmap_data, 
                       Plot_SettingsFile_Sample = Heatmap_design,
                       Plot_SettingsInfo = c(individual = "Pathway", color_Sample = list("Conditions","Biological_Replicates")),
                       Plot_SettingsFile_Metab =  MappingInfo,
                       OutputPlotName = "All")

```

To do:
2. Can individual also be used for samples? --> If not change this



### Bar/Box/Violin plots

```{r}


```



### Volcano plot
Here we will look at all the different options we have to display our results from the different analysis (DMA, MCA, GSE), which will help us to interpret our results as this can be sometimes difficult from the many data tables.

#### **Standard**
Here we will first look into the results from the differential analysis (see above 2.2 DMA) for the comparison of `HK2 versus 786M1A`:
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying DMA results."}
# Run with default parameter --> only need to provide Input_data and the title we like
MetaProViz::VizVolcano(Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA")
```
\
Next we may be interested to understand which metabolite clusters based on our MCA the metabolites of the plot correspond to. In order to do this we can provide a Plot_SettingsFile with this additional information and use this information to color code and/or to shape the dots on the volcano plot. In order to choose the right column we need to provide a vector Plot_SettingsInfo with this information.\
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying DMA results colour coded/shaped for metabolic clusters from MCA results."}
Settings <- MCAres[,c(1,15)]%>%
  rename("Metabolite"=1)

# Check our settings:
knitr::kable(Settings[1:4,] , caption = "Settings for plots.", row.names=FALSE)

#Now we need to add our Plot_SettingsFile and the Plot_SettingsInfo:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(color="RG3_SignificantChange"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA colour coded for metabolic clusters" )

#If we want to use the shape instead of the colour for the cluster info, we can just change our Plot_SettingsInfo
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(shape="RG3_SignificantChange"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters" )

#Of course, we can also adapt both, color and shape for the same parameter:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(shape="RG3_SignificantChange", color="RG3_SignificantChange"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters" )
```
\
Given that we also know, which metabolic pathway the metabolites correspond to, we can add this information into the plot too. \
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying DMA results colour coded for metabolic pathways and shaped for metabolic clusters from MCA results."}
Settings <- merge(Settings, MappingInfo, by="Metabolite", all.x=TRUE)

# Check our settings:
knitr::kable(Settings[1:4,] , caption = "Settings for plots.", row.names=FALSE)

#Now we can use color for the pathways and shape for the metabolite clusters:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(shape="RG3_SignificantChange", color="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters" )
```
\
We immediately see that there are many pathways displayed on the plot, which can make it difficult to interpret. Hence, we will change our plot settings in order to get individual plots for each of the pathways:
```{r Display_Not_Run, eval=FALSE}
#Now we can generate a plot for each pathway and color for the metabolite clusters:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(color="RG3_SignificantChange", individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters" )
```

<div class="vscroll-plot">
```{r Run_not_Display, echo=FALSE, fig.align="left", fig.width=7, fig.height=5}
#Now we can generate a plot for each pathway and color for the metabolite clusters:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(color="RG3_SignificantChange", individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters" )
```
</div>
\
\
\
If we have multiple clusters on one plot, we can also switch the colour legend to display as a pie chart, which gives us an overview on how much percent of each cluster is present in a pathway:
```{r , eval=FALSE}
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(color="RG3_SignificantChange", individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters",
                       Legend="Pie")
```

<div class="vscroll-plot">
```{r , echo=FALSE, fig.align="left", fig.width=7, fig.height=5}
#Now we can generate a plot for each pathway and color for the metabolite clusters:
MetaProViz::VizVolcano(Plot_Settings="Standard",
                       Plot_SettingsInfo= c(color="RG3_SignificantChange", individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA shape for metabolic clusters",
                       Legend="Pie")
```
</div>
\
\
\

#### **Comparison**

```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Comparison."}
MetaProViz::VizVolcano(Plot_Settings="Compare",
                       #Plot_SettingsInfo= c(color="RG3_SignificantChange", individual="Pathway"),
                       #Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       AdditionalInput_data=`DMA_HK2_vs_786-M2A`,
                       OutputPlotName= "HK2 vs. 786M1A compared to HK2 vs. 786M2A",
                       Subtitle= "Results of DMA" )
```


Now we do individual plots again:
```{r, eval=FALSE}
MetaProViz::VizVolcano(Plot_Settings="Compare",
                       Plot_SettingsInfo= c(individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       AdditionalInput_data=`DMA_HK2_vs_786-M2A`,
                       OutputPlotName= "HK2 vs. 786M1A compared to HK2 vs. 786M2A",
                       Subtitle= "Results of DMA" )
```

<div class="vscroll-plot">
```{r, echo=FALSE, fig.align="left", fig.width=7, fig.height=5}
MetaProViz::VizVolcano(Plot_Settings="Compare",
                       Plot_SettingsInfo= c(individual="Pathway"),
                       Plot_SettingsFile= Settings,
                       Input_data=`DMA_HK2_vs_786-M1A`,
                       AdditionalInput_data=`DMA_HK2_vs_786-M2A`,
                       OutputPlotName= "HK2 vs. 786M1A compared to HK2 vs. 786M2A",
                       Subtitle= "Results of DMA" )
```
</div>

#### **PathwayEnrichmentAnalysis**
If you have performed Pathway Enrichment Analysis (PEA) such as ORA or GSEA, we can also plot the results or add the information into the Figure legends.

```{r, eval=FALSE}

MetaProViz::VizVolcano(Plot_Settings="PEA",
                       Plot_SettingsInfo= c(individual="term", PEA_Pathway="ID", PEA_stat="p.adjust", PEA_score="GeneRatio"),
                       Plot_SettingsFile= KEGG_Pathways[,-3],#Must be the pathways used for pathway analysis
                       Input_data= HK2_vs_786M1A,# Must be the data you have used as an input for the pathway analysis
                       AdditionalInput_data=ORA_HK2_vs_786M1A,#Must be the results of the pathway analysis
                       OutputPlotName= "test",
                       Subtitle= "PEA" )

```


1. Plot_SettingsFile = Pathway file used for e.g. ORA. --> column term or pathway = individual
2. Additional_File = Results of ORA or GSEA
3. Rename setting GSE to something else as this could also be more unspecific and we don't do gene set enrichment, but metabolite!
4. Use subtitle to display the performed tests information --> this can be passed by the user by adding another column into Plot_SettingsInfo --> need to ensure that this column exists in Additional_File of ORA/GSEA --> this could e.g. NES score and p.adj of this pathway --> Here this would need to be combined before!



\
\
\

### Lollipop graphs

Lollipop graphs are another option to visualize the results from the different **MetaProViz** analysis.

#### **Standard**
Here we will first look into the results from DMA (see above 2.2 DMA) for the comparison of `HK2 versus 786M1A` using a plain graph:
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Standard figure displaying DMA results."}
# Run with default parameter --> only need to provide Input_data
MetaProViz::VizLolipop(Input_data=`DMA_HK2_vs_786-M1A`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA")
```
\
Next we may want to show additional information about the metabolites on the plot. We can change the dot size and/or color again using information from the Plot_SettingsFile by specifying it in the Plot_SettingsInfo vector.
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Lolipop displaying color and size option."}
MetaProViz::VizLolipop(Input_data = `DMA_HK2_vs_786-O`, 
                       Plot_SettingsInfo= c(color="t.val", size="p.adj"), 
                       Plot_SettingsFile= `DMA_HK2_vs_786-O`,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA")
```
\
We can also use the metabolite cluster information of our MCA to colorcode the metabolites while showing another information using the dot size. First we need to put the displaying information together in the Settings file.
```{r, fig.cap="Figure: Lolipop displaying metabolite clusters together."}
SettingsO <- merge(Settings,`DMA_HK2_vs_786-O`, by="Metabolite" )
# Check our settings:
knitr::kable(Settings[1:4,] , caption = "Settings for plots.", row.names=FALSE)
```

```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Lolipop displaying metabolite clusters together."}
MetaProViz::VizLolipop(Input_data = `DMA_HK2_vs_786-O`, 
           Plot_SettingsInfo= c(color="RG3_SignificantChange", size = "p.adj"), 
           Plot_SettingsFile= SettingsO,
           OutputPlotName= "HK2 versus 786O",
           Subtitle= "Results of DMA with MCA")
```
\
Alternatively we can make individual plot of each metabolite cluster
```{r, fig.align="left", fig.width=7, fig.height=5, fig.cap="Figure: Lolipop displaying metabolite clusters individually"}
MetaProViz::VizLolipop(Input_data = `DMA_HK2_vs_786-O`, 
                       Plot_SettingsInfo= c(color = "t.val", size = "p.val", individual= "RG3_SignificantChange"),
                       Plot_SettingsFile= SettingsO,
                       OutputPlotName= "HK2 versus 786M1A",
                       Subtitle= "Results of DMA with MCA")
```
\
We can also use lolipop plots to compare 2 or more DMA results by setting the value in Plot_Settings to "Compare". Here, we have to add a list of dataframes in the Input_data as well as a list of the names of the datasets to be used for displaying the data. Colorcoding is used for the datasets. 
```{r, eval=FALSE}
## Compare
MetaProViz::VizLolipop(Input_data = list(`DMA_HK2_vs_786-O`,`DMA_HK2_vs_786-M1A`), 
           Plot_Settings="Compare", 
           Comparison_name= list("Cond1", "Cond2"),
           OutputPlotName= "DMA HK2v786O versus DMA HK2v786M1A",
           Subtitle= "Results of DMA")

```
\
Again we can add a Plot_SettingsFile to use for the dot size. In compare mode the Plot_SettingsFile input has to be a list. 
```{r}
#  When  Plot_Settings="Compare" colorcoding of the different datasets is usel. Thus we can change only the size of the dots using the Plot_SettingsFile
MetaProViz::VizLolipop(Input_data = list(`DMA_HK2_vs_786-O`,`DMA_HK2_vs_786-M1A`),
           Plot_SettingsInfo= c(size = "t.val"),  
           Plot_Settings="Compare", 
           Comparison_name= list("Cond1", "Cond2"), 
           Plot_SettingsFile = list(`DMA_HK2_vs_786-O`,`DMA_HK2_vs_786-M1A`),
           OutputPlotName= "DMA HK2v786O versus DMA HK2v786M1A",
           Subtitle= "Results of DMA")

```
\
Finally we can compare the DMA results and make individual plots each cluster of the MCA.
```{r}
SettingsM1A <- merge(Settings,`DMA_HK2_vs_786-M1A`, by="Metabolite" )
knitr::kable(SettingsO[1:4,] , caption = "Settings for plots.", row.names=FALSE)
```

```{r}
VizLolipop(Input_data = list(`DMA_HK2_vs_786-O`,`DMA_HK2_vs_786-M1A`), 
           Plot_SettingsInfo= c(individual= "RG3_SignificantChange", size = "t.val"), 
           Plot_Settings="Compare", 
           Comparison_name= list("Cond1", "Cond2"), 
           Plot_SettingsFile = list(SettingsO,SettingsM1A),
           OutputPlotName= "DMA HK2v786O versus DMA HK2v786M1A",
           Subtitle= "Results of DMA for each Metabolite Cluster")
```

#### **PathwayEnrichmentAnalysis**
If you have performed Pathway Enrichment Analysis (PEA) such as ORA or GSEA, we can also plot the results or add the information into the Figure legends.
```{r}
MetaProViz::VizLolipop(Plot_Settings="PEA",
                       Plot_SettingsInfo= c(individual="term", PEA_Pathway="ID", PEA_stat="p.adjust", PEA_score="GeneRatio"),
                       Plot_SettingsFile= KEGG_Pathways[,-3],#Must be the pathways used for pathway analysis
                       Input_data= HK2_vs_786M1A,# Must be the data you have used as an input for the pathway analysis
                       AdditionalInput_data=ORA_HK2_vs_786M1A,#Must be the results of the pathway analysis
                       OutputPlotName= "test",
                       Subtitle= "PEA" )
```

### Alluvial plots
This is a rather specific plot that can be particularly useful to visulaise the output of the `MCA` module. 




Generally: Do a vignette just for visuals? --> use bigger dataset, which will showcase better the usability of the visuals (e.g. from CCLE).

<div class="progress progress-striped active">
  <div class="progress-bar progress-bar-success" style="width: 100%"></div>
</div>

# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessioninfo::session_info()
```

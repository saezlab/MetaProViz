---
title: "Enrichment Analysis"
author:
  - name: Christina Schmidt
    affiliation:
    - Heidelberg Universiy
    - name: Macabe Daley
    affiliation:
    - Heidelberg Universiy
output: 
  html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 5
    code_folding: show
vignette: >
  %\VignetteIndexEntry{Standard Metabolomics}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: bibliography.bib
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{=html}
<style>
.vscroll-plot {
    width: 1000px;
    height: 500px;
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>
```
```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# <img src="Hexagon_MetaProViz.png" align="right" width="200"/>

\
In this vignette we focus on accessing prior knowledge needed to for example run pathway enrichment analysis or compound class enrichment analysis and showcase the enrichment analysis using example data.\

\
[In this tutorial we showcase how to use **MetaProViz**]{style="text-decoration:underline"}:\

-   To access metabolite prior knowledge.\
-   To deal with many-to-many mapping in your metabolite identifiers.\
-   To perform pathway enrichment analysis.\
\
First if you have not done yet, install the required dependencies and load the libraries:
```{r message=FALSE, warning=FALSE}
# 1. Install Rtools if you havenâ€™t done this yet, using the appropriate version (e.g.windows or macOS). 
# 2. Install the latest development version from GitHub using devtools
#devtools::install_github("https://github.com/saezlab/MetaProViz")

library(MetaProViz)
devtools::load_all("C:/Users/chris/OneDrive/Documents/GitHub/MetaProViz")

#dependencies that need to be loaded:
library(tidyverse)

#Please install the Biocmanager Dependencies:
#BiocManager::install("clusterProfiler")
#BiocManager::install("EnhancedVolcano")
```
\
\

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 100%"}
:::
:::

# 1. Loading the example data

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 100%"}
:::
:::

[As part of the **MetaProViz** package you can load the example data into your global environment using the function `toy_data()`]{style="text-decoration:underline"}:\
`1.`Cell line experiment **(CellLine)**\
Here we choose an example datasets, which is publicly available on [metabolomics workbench project PR001418](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Project&ProjectID=PR001418) including metabolic profiles of human renal epithelial cells HK2 and cell renal cell carcinoma (ccRCC) cell lines cultured in Plasmax cell culture media [@Sciacovelli_Dugourd2022]. The raw data are available via [metabolomics workbench study ST002224](https://www.metabolomicsworkbench.org/data/DRCCMetadata.php?Mode=Study&StudyID=ST002224&StudyType=MS&ResultType=1) were intracellular metabolomics of HK2 and ccRCC cell lines 786-O, 786-M1A and 786-M2A were performed.\
We have performed pre-processing and differential analysis (details can be found in the vignette "Standard Metabolomics") and and here we load the differential metabolite analysis results for the comparison of 786M-1A versus HK2.\
```{r}
#Load the Pre-processed intracellular data:
Intra_DMA_786M1A_vs_HK2<- MetaProViz::ToyData(Data="IntraCells_DMA")
```

```{r, echo=FALSE}
# https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
# Check how our data looks like:
Intra_DMA_786M1A_vs_HK2[1:5, c(1:13)]%>%
  kableExtra::kbl(caption = "Preview of the DF `Intra_DMA_786M1A_vs_HK2` differential metaboilite analysis results.") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12) #%>%
  #kableExtra::scroll_box(width = "100%", height = "200px")
```

`2.` Tissue experiment **(Tissue)**\
Here we chose publicly available data from the [paper](https://www.cell.com/cancer-cell/comments/S1535-6108(15)00468-7#supplementaryMaterial) "An Integrated Metabolic Atlas of Clear Cell Renal Cell Carcinoma", which includes metabolomic profiling on 138 matched clear cell renal cell carcinoma (ccRCC)/normal tissue pairs.\
We have performed differential analysis (details can be found in the vignette "Metadata Analysis") and and here we load the differential metabolite analysis results for the comparison of Tumour versus Normal.\
```{r}
# Load the example data:
Tissue_TvsN <- MetaProViz::ToyData(Data="Tissue_DMA")
Tissue_TvsN_Old <- MetaProViz::ToyData(Data="Tissue_DMA_Old")
Tissue_TvsN_Young <- MetaProViz::ToyData(Data="Tissue_DMA_Young")

```

\
\

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 550%"}
:::
:::

# 2. Accessing Prior Knowledge

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 100%"}
:::
:::

\
Metabolite prior knowledge (PK) is essential for the interpretation of metabolomics data. It can be used to perform pathway enrichment analysis, compound class enrichment analysis, and by using specific PK databases, it can be used to study the connection of metabolites and receptors or transporters.Since the quality and content of the PK will dictate the success of the downstream analysis and biological interpretation, it is important to ensure the PK is used correctly.\
Specifically in metabolite PK, the many different PK databases and resources pose several issues. Indeed, the metabolite identifiers (e.g. KEGG, HMDB, PubChem, etc.) are not standardized across databases, and the same metabolite can have multiple identifiers in different databases. This is known as the many-to-many mapping problem (REF).\
Moreover, metabolic pathways that are the basis of the PK databases also includes co-factors such as ions or other small molecules that are not only part of most reactions, but can also not be detected in experimentallly acquired data (e.g. H2O, CO2, etc).


## KEGG pathway-metabolite sets
KEGG pathways that are loaded via KEGG API using the package `KEGGREST` and can be used to perform pathway analysis [@Kanehisa2000].
**(KEGG_Pathways)**\
```{r}
#This will use KEGGREST to query the KEGG API to load the pathways:
MetaProViz::LoadKEGG()
```
\
```{r, echo=FALSE}
# Check how our data looks like:
KEGG_Pathways[c(1:3,52:54),]%>%
  kableExtra::kbl(caption = "Preview of the DF `KEGG_Pathways`.") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

## Create pathway-metabolite sets
The function `Make_GeneMetabSet` can be used to translate gene names to metabolite names by using a PK network of metabolic reactions calles CosmosR (REF). This function is useful if you want to perform pathway enrichment analysis on available gene-sets such as the Hallmarks gene-sets from MSigDB (REF). Moroever, it enables you to perform combined pathway enrichment analysis on metabolite-gene sets, if you have other data types such as proteomics measuring the enzymes expression.\
The Hallmarks gene-set is available in the package `MetaProViz` and can be loaded using the function `LoadHallmarks()`.\
```{r}
#Load the example data:
MetaProViz::LoadHallmarks()
```
\
```{r, echo=FALSE}
# Check how our data looks like:
Hallmark_Pathways[c(997:998,2916:2917, 2916:2918),]%>%
  kableExtra::kbl(caption = "Preview of the DF `Hallmarks_Pathways` including gene-sets usable for pathway enrichment analysis.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```
\
Now we can use the function `Make_GeneMetabSet` to translate the gene names to metabolite names.\
```{r}
# *Add save function!!!! 
# * Enable to output pathway-metabolite-set or pathway-metabolite-gene set

#Translate gene names to metabolite names
Hallmarks_GeneMetab <- MetaProViz::Make_GeneMetabSet(Input_GeneSet=Hallmark_Pathways,
                                                     Target=c("gene"),
                                                     OutputName=NULL,
                                                     FolderPath = NULL)

```

```{r, echo=FALSE}
# Check how our data looks like:
Hallmarks_GeneMetab%>%
  filter(term=="HALLMARK_GLYCOLYSIS")%>%
   slice(c(59,142,193, 201:203))%>%
  kableExtra::kbl(caption = "Preview of the DF `Hallmarks_GeneMetab` including gene-sets usable for pathway enrichment analysis.") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)

```

```{r}
#plot out how the metabolite set size is different from the original gene-set size
#Show bar graph of the size of the gene set versus the metabolite set


```

-   Add CosmosR dependency to function built

-   Show both tables (pathways gene names and pathways metabolite names) and show the difference in size (e.g. 10% of the genes are translated to metabolites, 90% are not metabolic enzymes and hence only genes)

-   Discuss option to run metabolite-gene set analysis together.Discuss implications of size this poses

## MetaLinksDB Metabolite-receptor sets
The MetaLinks database is a manually curated database of metabolite-receptor and metabolite-transporter sets that can be used to study the connection of metabolites and receptors or transporters (REF).\

```{r}
MetaProViz:::LoadMetalinks()
```

```{r, echo=FALSE}
# Check how our data looks like:
MetalinksDB[c(1:8),]%>%
  kableExtra::kbl(caption = "Preview of the DF `MetaLinks` including metabolite-receptor sets.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)

```


# 3. Translate IDs

As seen above, we have just loaded the KEGG pathways.
Currently however, the MetaboliteID is in the form of a KEGG identifier.
What if we want to convert or 'translate' this ID to another commonly used form of ID, for instance because our measured data uses another type of ID?

Currently we support ID translation of metabolites to and from the following formats:

-   KEGG

-   HMDB

-   ChEBI

-   PubChem

To achieve this, we use [OmniPathR](https://www.bioconductor.org/packages/release/bioc/html/OmnipathR.html) and [RaMP DB](https://rampdb.nih.gov/) on the backend of our function.

```{r, echo=FALSE}
TranslateID(KEGG_Pathways[39,]) %>%
  kableExtra::kbl(caption = "Example of 1-to-one translation of `KEGG_Pathways` (besides HMDB)") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

However there are some important caveats with the standard TranslateID function, which we will discuss briefly here.

Using the default translation settings for a single ID, we can see that we receive back a single PubChem ID and ChEBI ID. However the HMDB column has two HMDBs associated with it (HMDB0001022, HMDB01022).
In this case this difference is trivial and due to HMDB formatting conventions: the longer version appears to be from the original HMDB ID format versus the shorter more concise version.
To avoid this we could change the settings to remove HMDB completely, like so:

```{r, echo=FALSE}
TranslateID(KEGG_Pathways[39,], 
            SettingsInfo = list(IdColumn="MetaboliteID", 
                                FromFormat=c("kegg"), 
                                ToFormat=c("pubchem","chebi"), 
                                Method="GetAll", 
                                GroupingVariable="term")) %>%
  kableExtra::kbl(caption = "Example of 1-to-one translation of `KEGG_Pathways` (besides HMDB)") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

Or, we could keep just the first item of every translation by changing the \`Method='GetFirst'\` parameter like so:

```{r}
TranslateID(KEGG_Pathways[39,], 
            SettingsInfo = list(IdColumn="MetaboliteID", 
                                FromFormat=c("kegg"), 
                                ToFormat=c("pubchem","chebi", "hmdb"), 
                                Method="GetFirst", 
                                GroupingVariable="term")) %>% 
  kableExtra::kbl(caption = "Example of 1-to-one translation of `KEGG_Pathways` (taking only the first hits)") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

Ideally we would want a smarter more consistent way to filter these out (more on this soon).
However, it is important to note that this translation process is rarely as straightforward as the one-to-one translation above (at least for PubChem and ChEBI IDs in the example).
Very commonly, an ID from one format will have a genuine one-to-many relationship with the other format (e.g. one KEGG ID maps to multiple HMDB IDs).
Occasionally, it could also be a many-to-many relationship, where some of the IDs from the new format link back to multiple IDs in the original format (e.g. two different KEGG IDs map to multiple HMDS IDs, some of which are shared between them).
We can inspect instances of where this is the case in our data:

```{r}
KEGG_Pathways %>% filter(MetaboliteID == 'C00009') %>% first() %>%
  TranslateID() %>%
  kableExtra::kbl(caption = "Example of 1-to-many translation of `KEGG_Pathways`") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

The above example of the Orthophosphate metabolite (KEGG ID C00009) shows the complexity of this one-to-many multi-mapping issue: for the single KEGG ID, it returns 4 different PubChem IDs, 4 different ChEBI IDs, and 10 different HMDB IDs.
For pathway analysis we would want to keep only one metabolite for each pathway.
But we would probably want to keep our metabolite choice across pathways, avoid ambiguous mapping as much as possible (many-to-many mapping), and have this metabolite ID selection guided by any IDs we might have available to us in our input data.
This leads us to the next function: Filter IDs.

*Previous notes from Christina:*

-   *Maybe add HMDB IDs and CheBI IDs (only if trial shows its somewhat straight forward - maybe let's use RampDB for this!)*
-   *If using RaMP to translate is easy, maybe we can transform this into a helper function that we reuse for the other translations we could/should do (comments below) --\> Either via API or via their functions!*
-   *Make Ion file and unspecific molecules file in an automated manner (at the moment it is manual in the LoadKEGG): Also extract ions from HMDB to enable the removal of ions from the pathways, same for xenobiotics and masspec unspecific molecules (H2O, CO2, etc.) --\> should be helper function that also communicates removal --\> Can be set TRUE/FALSE dependent on the users wihses (default=TRUE)*

## Filter IDs

TODO

Use cases:

1.  Filter out translations with clear redundancy (e.g. different HMDB formats)
2.  Filter based on user provided data (aka measured data)
3.  Filter based on many-many mapping

## Reactome

-   As we already did most of the API retrieval, we can consider to add `MetaProViz::LoadReactome`
-   Remove unspecific metabolites
-   Translate ChEBI to HMDB and KEGG

FYI: See code I used to access via API



## ocean PK

-   Add HMDB and CheBI IDs to the KEGG IDs.
-   Make ocean PK accessible via MetaProViz

`MetaProViz::LoadOcean`

## Summary

### Clustering

-   Summarize the PK based on overlap between terms --\> hierarchical clustering (maybe enable multiple options here)
-   Summarize PK based on term-names and/or overlap?
-   Create function that can be used to cluster the results of the pathway analysis --\> basically adds column ClusterName to pathway results file --\> ClusterName is either `No Cluster` or the main words from the pathway names that are combined.

Almost like cleaning of prior knowledge

### Lipid prediction

This goes into the direction of linex where we will use the lipidPKN and the reaction rules to also use lipids that are not in the prior knowledge when doing downstream analsyis!
\* linex2 PKN is manually curated - instead of using this we may want to make am updateable version.
\* Now we can at least do understand the classes present \* LipidMaps IDs, can we link other ID types?

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 550%"}
:::
:::

# Check Names

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 550%"}
:::
:::

-   Add MetaProViz::CheckNames --\> showcase with other data maybe (data where we do have doublons or missing IDs?) --\> explain here why this is needed in metabolomics

```{r}

##
## ---------------------------

#' CheckNames
#'
#' 
#'
#' @param InputData DF including column with metabolite IDs (e.g. HMDB IDs) and associated trivial metabolite names.
#' @param SettingsInfo Named vector including the column name of the ID column and the trivial metabolite name column c(ID="ColumnName_InputData", TrivialName= "ColumnName_InputData").If Class=TRUE, columnName for class needs to be provided c(Class=ColumnName_InputData). If Network is provided, also column name for the metabolite ID must be provided IDNetwork="ColumnName_Network".
#' @param Long \emph{Optional: } FALSE if metabolite IDs that map to multiple trivial names are separated by comma and TRUE if the InputData is already long, meaning each metabolite ID is in a separate row and hence trivial names were duplicated if multiple metabolite IDs were associated with the trivial name. \strong{Default = FALSE}
#' @param Class \emph{Optional:} TRUE or FALSE, weather column including information about metabolite class is provided in InputData. If TRUE, also column name for the metabolite ID must be provided via SettingsInfo. \strong{Default = FALSE}
#' @param Network Network used as input for enrichment analysis. If not available set to NULL. If Network is provided, also column name for the metabolite ID must be provided via SettingsInfo.
#' @param 
#'
#' @export

CheckNames <- function(InputData, 
                       SettingsInfo, 
                       Long=FALSE,
                       Class=FALSE,
                       Network=NULL){
  
  #----- Make long DF if needed:
  if(Long==FALSE){
    df_long <- InputData %>% #Make DF long based on Metablite IDs
      rownames_to_column(SettingsInfo[["TrivialName"]])%>%
      separate_rows(SettingsInfo[["ID"]], sep = ",")
    
    df_NoNA <- df_long %>%
      filter(!is.na(.data[[SettingsInfo[["ID"]]]]))
  }else{
    df_long <- InputData
    df_NoNA <- InputData%>%
      filter(!is.na(.data[[SettingsInfo[["ID"]]]]))
  }
  
  #----- Check for many to many mappings:
  doublons_ID <- as.data.frame(df_NoNA[duplicated(df_NoNA[SettingsInfo[["ID"]]]), SettingsInfo[["ID"]]])
  doublons_TrivialName <- as.data.frame(df_NoNA[duplicated(df_NoNA[SettingsInfo[["TrivialName"]]]), SettingsInfo[["TrivialName"]]])
  
  #print the information obtained
  message("In InputData are ", nrow(df), " trivial metabolite names. For ", nrow(df_long)-nrow(df_NoNA), " metabolites no metabolite ID was mapped. Of the mapped metabolite IDs ", nrow(unique(doublons_ID)), " were mapped to multiple trivial metabolite names. ", nrow(unique(doublons_TrivialName)), " trivial metabolite names mapped to multiple metabolite IDs.")
  
  #----- Check if the duplications are of a specific metabolite class (e.g. lipids)
  if(Class==TRUE){
    doublons_ID <- merge(x= as.data.frame(unique(doublons_ID)),
                       y= df_NoNA,
                       by=SettingsInfo[["ID"]],
                       all.x=TRUE)
    doublons_Summary <-  as.data.frame(prop.table(table(doublons_ID[SettingsInfo[["Class"]]])) * 100)%>%
      dplyr::rename(!!SettingsInfo[["TrivialName"]]:= 1)
    print(doublons_Summary)
  }
  
  #Check pathway file (if provided):
  if(is.null(Network)==FALSE){
    
  }
  
}


```

\
\

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 550%"}
:::
:::

# 3. Run enrichment analysis

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 550%"}
:::
:::

## ORA using the DMA results

Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method that determines if a set of features (=metabolic pathways) are over-represented in the selection of features (=metabolites) from the data in comparison to all measured features (metabolites) using the Fishers exact test.
The selection of metabolites are usually the most altered metabolites in the data, which can be selected by the top and bottom t-values.\
Of course, there are many other PEA methods such as the well known GSEA.
Here we do not aim to provide an extensive tool for different methods to perform pathway enrichment analysis and only focus on ORA since we can apply this to perform standard pathway enrichment as well as pathway enrichment on clusters of metabolites.
If you are interested in using different pathway enrichment methods please check out specialized tools such as [decopupleR](https://saezlab.github.io/decoupleR/) [@Badia-I-Mompel2022].\

\
Here we will use the KEGG pathways [@Kanehisa2000].
Before we can perform ORA on the DMA results, we have to ensure that the metabolite names match with the KEGG IDs or KEGG trivial names.
In general, the `PathwayFile` requirements are column "term", "Metabolite" and "Description", and the `Input_data` requirements are column "t.val" and column "Metabolite".\

```{r}
#Since we have performed multiple comparisons (all_vs_HK2), we will run ORA for each of this comparison
DM_ORA_res<- list()

comparisons <- names(DMA_Annova[["DMA"]])
for(comparison in comparisons){
  #Ensure that the Metabolite names match with KEGG IDs or KEGG trivial names. 
  DMA <- DMA_Annova[["DMA"]][[comparison]]
  DMA <- DMA[complete.cases(DMA),-1]%>%#we remove metabolites that do not have a KEGG ID/KEGG pathway
  dplyr::rename("Metabolite"="KEGGCompound")#We use the KEGG trivial names to match with the KEGG pathways
  
  #Perform ORA
  DM_ORA_res[[comparison]] <- MetaProViz::StandardORA(InputData= DMA%>%remove_rownames()%>%column_to_rownames("Metabolite"), #Input data requirements: column `t.val` and column `Metabolite`
                                                       SettingsInfo=c(pvalColumn="p.adj", PercentageColumn="t.val", PathwayTerm= "term", PathwayFeature= "Metabolite"),
                                                       PathwayFile=KEGG_Pathways,#Pathway file requirements: column `term`, `Metabolite` and `Description`. Above we loaded the Kegg_Pathways using MetaProViz::Load_KEGG()
                                                       PathwayName="KEGG",
                                                       minGSSize=3,
                                                       maxGSSize=1000,
                                                       pCutoff=0.01,
                                                       PercentageCutoff=10)
                                                
                                                 
}

#Lets check how the results look like:
DM_ORA_786M1A_vs_HK2 <- DM_ORA_res[["786-M1A_vs_HK2"]][["ClusterGoSummary"]]
```

```{r, echo=FALSE}
# Check how our data looks like:
DM_ORA_786M1A_vs_HK2[c(1:5),-1]%>%
  kableExtra::kbl(caption = "Preview of the ORA results for the comparison of 786-M1A versus HK2 cells.", row.names=FALSE) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria", font_size = 12)
```

\*implementation to also apply to clusters!

## ORA on each metabolite cluster

As explained in detail above, Over Representation Analysis (ORA) is a pathway enrichment analysis (PEA) method.
As ORA is based on the Fishers exact test it is perfect to test if a set of features (=metabolic pathways) are over-represented in the selection of features (= clusters of metabolites) from the data in comparison to all measured features (all metabolites).
In detail, `MC_ORA()` will perform ORA on each of the metabolite clusters using all metabolites as the background.

```{r, eval=FALSE}
MC_ORA_result <- MetaProViz::ClusterORA(InputData=MCAres[["MCA_2Cond_Results"]]%>%column_to_rownames("Metabolite"),
                                         SettingsInfo=c(ClusterColumn="RG2_Significant", 
                                                        BackgroundColumn="BG_Method", 
                                                        PathwayTerm= "Pathway", #This is the column name including the pathways names
                                                        PathwayFeature= "Metabolite"),
                                         RemoveBackground=TRUE,
                                         PathwayFile=MappingInfo%>%rownames_to_column("Metabolite"),
                                         PathwayName="KEGG",
                                         minGSSize=3,
                                         maxGSSize=1000 ,
                                         SaveAs_Table= "csv")
```

## decoupleR

Just as an example if people want to use different forms of statistical test

## Run footprinting analysis

-   Maybe move to extra vignette
-   ocean method --\> MetaProViz::RunOcean

# 4. Visualisation of results

## Heatmaps

Add parameter `Plot_Settings` and enable "PEA" versus "Standard"

## Volcano plot

In general,we have three different `Plot_Settings`, which will also be used for other plot types such as lollipop graphs.\
`1.` `"Standard"` is the standard version of the plot, with one dataset being plotted.\
`2.` `"Conditions"` here two or more datasets will be plotted together.
How datasets can be plotted together depends on the plot type.\
`3.` `"PEA"` stands for Pathway Enrichment Analysis, and is used if the results of an GSE analysis should be plotted as here the figure legends will be adapted.\

##Future
Run metabolite-gene analysis
\* Maybe add cosmos data - this also has matched transcriptomics (otherwise there are also the CPTAC data for ccRCC) and Cissys data are to be published soon as well.
\* Maybe add the data from the paper of the 3D cell culture model of ccRCC




</div>

\
\

::: {.progress .progress-striped .active}
::: {.progress-bar .progress-bar-success style="width: 100%"}
:::
:::

# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessioninfo::session_info()
```

# Bibliography
